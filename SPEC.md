# Grammar School – Project Specification

*A multi-language framework for building tiny LLM-friendly DSLs*

---

## 1. Overview

**Grammar School** is a lightweight, multi-language framework for creating small, precise, LLM-friendly domain-specific languages (DSLs). It provides:

* A way to **define grammar rules** (via strings or structured combinators)
* A way to **map DSL verbs to semantic handlers**
* A **parser → AST → interpreter → actions → runtime** pipeline
* Independent implementations in **Python** and **Go** (and potentially TypeScript)

Grammar School does *not* require interop between languages. Each implementation is standalone but follows the same conceptual model.

---

## 2. Core Concepts (Language-Agnostic)

All language implementations follow this shared conceptual design.

### 2.1 DSL Program

A DSL program is a plain string, typically generated by an LLM under CFG constraints:

```text
track(name="Drums").add_clip(start=0, length=8)
Cmaj7(1,1), Fmaj7(2,1)
tracks().filter(name~="FX").mute()
```

---

### 2.2 Abstract Syntax Tree (AST)

Grammar School uses the following conceptual AST types:

```
Value:
  kind: "number" | "string" | "identifier" | etc.
  value: any

Arg:
  name: string
  value: Value

Call:
  name: string
  args: Map<string,Value>

CallChain:
  calls: Call[]
```

Each implementation represents these using native language types (e.g., Python dataclasses, Go structs).

---

### 2.3 Actions (Interpreter Output)

Semantic evaluation produces `Action` objects:

```
Action:
  kind: string           # e.g. "create_track", "add_clip", "note"
  payload: Map<String,Any>
```

These are runtime instructions executed later by a domain-specific runtime.

---

### 2.4 Lifecycle

Every implementation follows the same pipeline:

```
DSL code (string)
   → Parse
       → CallChain (AST)
           → Interpret
               → []Action (plan)
                   → Execute (runtime)
```

---

## 3. Repository Structure (Monorepo)

Grammar School uses a multi-language monorepo:

```
grammar-school/
  README.md
  SPEC.md                # shared conceptual spec (this document)

  python/
    pyproject.toml
    grammar_school/
      __init__.py
      ast.py
      runtime.py
      grammar.py
      backend_lark.py
      interpreter.py
    examples/

  go/
    go.mod
    gs/
      ast.go
      action.go
      context.go
      engine.go
      runtime.go
      parser_backend.go
    examples/

  ts/                    # (optional) future implementation
    package.json
    src/
    examples/
```

Each language is self-contained: its own build system, its own package/module, its own users, but they share the same conceptual spec.

---

## 4. Python Specification (`python/grammar_school`)

### 4.1 AST Types (`ast.py`)

```python
@dataclass
class Value:
    kind: str
    value: Any

@dataclass
class Arg:
    name: str
    value: Value

@dataclass
class Call:
    name: str
    args: Dict[str, Value]

@dataclass
class CallChain:
    calls: List[Call]
```

---

### 4.2 Runtime Types (`runtime.py`)

```python
@dataclass
class Action:
    kind: str
    payload: Dict[str, Any]

class Runtime(Protocol):
    def execute(self, action: Action) -> None:
        ...
```

---

### 4.3 Grammar Definition (`grammar.py`)

#### `Grammar` base class:

```python
class Grammar:
    def parse(self, code: str) -> CallChain: ...
    def compile(self, code: str) -> list[Action]: ...
    def execute(self, code_or_plan, runtime: Runtime) -> None: ...
```

#### `@rule` decorator

Supports *three* forms:

```python
@rule("call_chain: call ('.' call)*")
@rule(call_chain="call ('.' call)*")
@rule(call_chain = sym("call") + many(lit(".") + sym("call")))
```

#### Symbolic grammar combinators

```python
sym("call")               # nonterminal
lit(".")                  # literal terminal
sym("call") + lit("(")    # sequence
A | B                     # choice
many(X)                   # X*
X.optional()              # [X]
```

#### `@verb` decorator

Marks a method as the semantic handler for a verb:

```python
@verb
def track(self, name, color=None, _context=None):
    return Action(kind="create_track", payload={...})
```

---

### 4.4 Interpreter (`interpreter.py`)

Responsibilities:

* Walk `CallChain`
* For each `Call`:
  * coerce `Value` → native Python types
  * dispatch to verb method
  * collect returned `Action`s
  * track optional context

Produces: `List[Action]`.

---

## 5. Go Implementation Specification (`go/gs/`)

### 5.1 AST (`ast.go`)

```go
type ValueKind int
const (
    ValueNumber ValueKind = iota
    ValueString
    ValueIdentifier
    ValueBool
)

type Value struct {
    Kind ValueKind
    Num  float64
    Str  string
    Bool bool
}

type Arg struct {
    Name  string
    Value Value
}

type Call struct {
    Name string
    Args []Arg
}

type CallChain struct {
    Calls []Call
}
```

---

### 5.2 Action + Runtime (`action.go`, `runtime.go`)

```go
type Action struct {
    Kind    string                 `json:"kind"`
    Payload map[string]interface{} `json:"payload"`
}

type Runtime interface {
    ExecuteAction(ctx context.Context, a Action) error
}
```

---

### 5.3 Verb Handlers

Go uses reflection to bind methods with signature:

```go
func (d *MyDSL) VerbName(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error)
```

Where:

```go
type Args map[string]Value
```

---

### 5.4 Engine

```go
type Engine struct {
    grammar string
    parser  Parser
    verbs   map[string]VerbHandler
}

func NewEngine(grammar string, dsl any, parser Parser) (*Engine, error)
func (e *Engine) Compile(code string) ([]Action, error)
func (e *Engine) Execute(ctx context.Context, runtime Runtime, plan []Action) error
```

`Parser` is a pluggable interface:

```go
type Parser interface {
    Parse(input string) (*CallChain, error)
}
```

This allows `participle`, `pigeon`, or custom PEG/EBNF backends.

---

## 6. Equality of Implementations

* Python and Go implementations must follow the *same conceptual design*.
* They do **not** share code.
* They do **not** depend on each other.
* They do **not** need to interoperate.
* They simply implement the same grammar → AST → actions flow.

This gives: consistency, flexibility, multi-runtime choice, no forced coupling.

---

## 7. What's Not in Scope

* Not a full compiler toolkit
* Not intended to replace ANTLR, LALR tools, or PEG frameworks
* No static type inference
* No necessity for Rust, C++, WASM, or cross-language FFI
* No cross-language runtime communication by default

Each implementation stands on its own.

---

## 8. Roadmap (Optional)

### Phase 1: Python + Go MVP

* Grammar definition
* Parser backend
* AST
* Interpreter
* Action runtime
* Examples (music DSL, automation DSL)

### Phase 2: TypeScript

* Browser + Node parsing/interpreting
* DSL playground

### Phase 3: Prebuilt DSLs

* Music
* Automation
* Pipelines
* Agents
* Query languages

---

## 9. License / Maintainers

**License**: MIT License

Copyright (c) 2024 Conceptual Machines

See [LICENSE](../LICENSE) file for full license text.

