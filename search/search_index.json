{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Grammar School","text":"<p>A multi-language framework for building tiny LLM-friendly DSLs</p> <p>Grammar School is a lightweight, multi-language framework for creating small, precise, LLM-friendly domain-specific languages (DSLs). It provides a simple way to define grammar rules, map DSL methods to implementations, and execute DSL programs through a clean parser \u2192 AST \u2192 interpreter \u2192 execute pipeline.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udfaf Simple Grammar Definition - Define grammars via strings or structured combinators</li> <li>\ud83d\udd17 Method Mapping - Map DSL methods to implementations with decorators/annotations</li> <li>\ud83d\udd04 Complete Pipeline - Parse \u2192 Interpret \u2192 Execute workflow</li> <li>\ud83c\udf0d Multi-Language - Independent implementations in Python and Go</li> <li>\ud83e\udd16 LLM-Friendly - Designed for LLM-generated DSL code</li> <li>\ud83d\udce6 Lightweight - Minimal dependencies, focused API</li> <li>\ud83d\udd27 OpenAI CFG Integration - Built-in utilities for GPT-5 Context-Free Grammar constraints</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"PythonGo <pre><code>from grammar_school import Grammar, method\n\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL()\ndsl.execute('greet(name=\"World\")')\n# Output: Hello, World!\n</code></pre> <pre><code>type MyDSL struct{}\n\nfunc (d *MyDSL) Greet(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    name := args[\"name\"].Str\n    action := gs.Action{\n        Kind: \"greet\",\n        Payload: map[string]interface{}{\n            \"name\": name,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n\ntype MyRuntime struct{}\n\nfunc (r *MyRuntime) ExecuteAction(ctx context.Context, a gs.Action) error {\n    fmt.Printf(\"Hello, %v!\\n\", a.Payload[\"name\"])\n    return nil\n}\n\ndsl := &amp;MyDSL{}\nengine, _ := gs.NewEngine(\"\", dsl, parser)\nruntime := &amp;MyRuntime{}\nplan, _ := engine.Compile(`greet(name=\"World\")`)\nengine.Execute(context.Background(), runtime, plan)\n// Output: Hello, World!\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>DSL Code (string)\n   \u2193\nParse \u2192 CallChain (AST)\n   \u2193\nInterpret \u2192 Execute methods directly\n</code></pre> <p>All implementations follow the same conceptual design, ensuring consistency across languages while remaining independent.</p>"},{"location":"#installation","title":"Installation","text":"PythonGo <pre><code>pip install grammar-school\n</code></pre> <pre><code>cd go\ngo mod download\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Quick start guide</li> <li>Python API - Python implementation documentation</li> <li>Go API - Go implementation documentation</li> <li>Examples - Example DSLs and use cases</li> <li>Specification - Complete framework specification</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Grammar School! This document provides guidelines and instructions for contributing.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>See the main CONTRIBUTING.md file in the repository root for complete setup instructions.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Install dependencies\ncd python\npip install -e \".[docs]\"\n\n# Serve locally\ncd ../docs\nmkdocs serve\n\n# Build for production\nmkdocs build\n\n# Deploy to GitHub Pages (requires push access)\nmkdocs gh-deploy\n</code></pre>"},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use Markdown for all documentation</li> <li>Follow the existing structure</li> <li>Include code examples for both Python and Go when relevant</li> <li>Use the Material theme features (tabs, admonitions, etc.)</li> </ul>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<ul> <li>Python API docs are auto-generated using <code>mkdocstrings</code></li> <li>Go API docs are manually written (can be enhanced with godoc integration)</li> <li>Keep API docs up to date with code changes</li> </ul>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                 # Homepage\n\u251c\u2500\u2500 getting-started/         # Getting started guides\n\u251c\u2500\u2500 python/                  # Python API docs\n\u251c\u2500\u2500 go/                      # Go API docs\n\u251c\u2500\u2500 examples/                # Example DSLs\n\u251c\u2500\u2500 specification.md         # Framework specification\n\u2514\u2500\u2500 mkdocs.yml              # MkDocs configuration\n</code></pre>"},{"location":"contributing/#style-guide","title":"Style Guide","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Use tabs for language-specific examples</li> <li>Add diagrams where helpful (Mermaid supported)</li> </ul>"},{"location":"specification/","title":"Specification","text":"<p>This document provides the complete specification for Grammar School. All implementations (Python, Go, and future languages) must follow this conceptual design.</p>"},{"location":"specification/#overview","title":"Overview","text":"<p>Grammar School is a lightweight, multi-language framework for creating small, precise, LLM-friendly domain-specific languages (DSLs). It provides:</p> <ul> <li>A way to define grammar rules (via strings or structured combinators)</li> <li>A way to map DSL verbs to semantic handlers</li> <li>A parser \u2192 AST \u2192 interpreter \u2192 actions \u2192 runtime pipeline</li> <li>Independent implementations in Python and Go (and potentially TypeScript)</li> </ul> <p>Grammar School does not require interop between languages. Each implementation is standalone but follows the same conceptual model.</p>"},{"location":"specification/#core-concepts","title":"Core Concepts","text":""},{"location":"specification/#dsl-program","title":"DSL Program","text":"<p>A DSL program is a plain string, typically generated by an LLM under CFG constraints:</p> <pre><code>track(name=\"Drums\").add_clip(start=0, length=8)\nCmaj7(1,1), Fmaj7(2,1)\ntracks().filter(name~=\"FX\").mute()\n</code></pre>"},{"location":"specification/#abstract-syntax-tree-ast","title":"Abstract Syntax Tree (AST)","text":"<p>Grammar School uses the following conceptual AST types:</p> <pre><code>Value:\n  kind: \"number\" | \"string\" | \"identifier\" | \"bool\"\n  value: any\n\nArg:\n  name: string\n  value: Value\n\nCall:\n  name: string\n  args: Map&lt;string,Value&gt;\n\nCallChain:\n  calls: Call[]\n</code></pre> <p>Each implementation represents these using native language types (e.g., Python dataclasses, Go structs).</p>"},{"location":"specification/#actions-interpreter-output","title":"Actions (Interpreter Output)","text":"<p>Semantic evaluation produces <code>Action</code> objects:</p> <pre><code>Action:\n  kind: string           # e.g. \"create_track\", \"add_clip\", \"note\"\n  payload: Map&lt;String,Any&gt;\n</code></pre> <p>These are runtime instructions executed later by a domain-specific runtime.</p>"},{"location":"specification/#lifecycle","title":"Lifecycle","text":"<p>Every implementation follows the same pipeline:</p> <pre><code>DSL code (string)\n   \u2192 Parse\n       \u2192 CallChain (AST)\n           \u2192 Interpret\n               \u2192 []Action (plan)\n                   \u2192 Execute (runtime)\n</code></pre>"},{"location":"specification/#python-specification","title":"Python Specification","text":"<p>See the Python API documentation for the complete Python implementation specification.</p>"},{"location":"specification/#go-specification","title":"Go Specification","text":"<p>See the Go API documentation for the complete Go implementation specification.</p>"},{"location":"specification/#equality-of-implementations","title":"Equality of Implementations","text":"<ul> <li>Python and Go implementations must follow the same conceptual design.</li> <li>They do not share code.</li> <li>They do not depend on each other.</li> <li>They do not need to interoperate.</li> <li>They simply implement the same grammar \u2192 AST \u2192 actions flow.</li> </ul> <p>This gives: consistency, flexibility, multi-runtime choice, no forced coupling.</p>"},{"location":"specification/#whats-not-in-scope","title":"What's Not in Scope","text":"<ul> <li>Not a full compiler toolkit</li> <li>Not intended to replace ANTLR, LALR tools, or PEG frameworks</li> <li>No static type inference</li> <li>No necessity for Rust, C++, WASM, or cross-language FFI</li> <li>No cross-language runtime communication by default</li> </ul> <p>Each implementation stands on its own.</p>"},{"location":"examples/building-dsl/","title":"Building Your DSL","text":"<p>A guide to building your own DSL with Grammar School.</p>"},{"location":"examples/building-dsl/#step-1-define-your-methods","title":"Step 1: Define Your Methods","text":"<p>Methods are the functions that your DSL will support. They contain the actual implementation.</p> PythonGo <pre><code>from grammar_school import Grammar, method\n\nclass MyDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.users = []\n        self.emails_sent = []\n\n    @method\n    def create_user(self, name, email):\n        user = {\"name\": name, \"email\": email}\n        self.users.append(user)\n        print(f\"Created user: {name}\")\n\n    @method\n    def send_email(self, to, subject):\n        email = {\"to\": to, \"subject\": subject}\n        self.emails_sent.append(email)\n        print(f\"Sent email to {to}\")\n</code></pre> <pre><code>type MyDSL struct{}\n\nfunc (d *MyDSL) CreateUser(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    name := args[\"name\"].Str\n    email := args[\"email\"].Str\n    action := gs.Action{\n        Kind: \"create_user\",\n        Payload: map[string]interface{}{\n            \"name\":  name,\n            \"email\": email,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n\nfunc (d *MyDSL) SendEmail(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    to := args[\"to\"].Str\n    subject := args[\"subject\"].Str\n    action := gs.Action{\n        Kind: \"send_email\",\n        Payload: map[string]interface{}{\n            \"to\":      to,\n            \"subject\": subject,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n</code></pre>"},{"location":"examples/building-dsl/#step-2-use-your-dsl","title":"Step 2: Use Your DSL","text":"<p>With the unified interface, methods execute directly - no Runtime needed!</p> PythonGo <pre><code># Create your DSL instance\ndsl = MyDSL()\n\n# Execute DSL code - methods run directly\ndsl.execute('create_user(name=\"Alice\", email=\"alice@example.com\")')\ndsl.execute('send_email(to=\"bob@example.com\", subject=\"Hello\")')\n\n# Access state if needed\nprint(f\"Users: {dsl.users}\")\nprint(f\"Emails sent: {dsl.emails_sent}\")\n</code></pre> <pre><code>type MyRuntime struct {\n    users      []map[string]interface{}\n    emailsSent []map[string]interface{}\n}\n\nfunc (r *MyRuntime) ExecuteAction(ctx context.Context, a gs.Action) error {\n    switch a.Kind {\n    case \"create_user\":\n        user := map[string]interface{}{\n            \"name\":  a.Payload[\"name\"],\n            \"email\": a.Payload[\"email\"],\n        }\n        r.users = append(r.users, user)\n        fmt.Printf(\"Created user: %v\\n\", user[\"name\"])\n\n    case \"send_email\":\n        email := map[string]interface{}{\n            \"to\":      a.Payload[\"to\"],\n            \"subject\": a.Payload[\"subject\"],\n        }\n        r.emailsSent = append(r.emailsSent, email)\n        fmt.Printf(\"Sent email to %v\\n\", email[\"to\"])\n    }\n    return nil\n}\n</code></pre>"},{"location":"examples/building-dsl/#step-3-use-your-dsl","title":"Step 3: Use Your DSL","text":"PythonGo <pre><code>dsl = MyDSL()\n\ncode = '''\ncreate_user(name=\"Alice\", email=\"alice@example.com\")\nsend_email(to=\"alice@example.com\", subject=\"Welcome!\")\n'''\n\ndsl.execute(code)\n</code></pre> <pre><code>dsl := &amp;MyDSL{}\nengine, _ := gs.NewEngine(\"\", dsl, parser)\nruntime := &amp;MyRuntime{}\n\ncode := `\ncreate_user(name=\"Alice\", email=\"alice@example.com\")\nsend_email(to=\"alice@example.com\", subject=\"Welcome!\")\n`\n\nplan, _ := engine.Compile(code)\nengine.Execute(context.Background(), runtime, plan)\n</code></pre>"},{"location":"examples/building-dsl/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Methods Simple - Each method should do one thing</li> <li>Use Meaningful Method Names - Make method names descriptive</li> <li>Handle Errors - Validate inputs and handle errors appropriately</li> <li>Maintain State Carefully - Use <code>self</code> attributes to manage state</li> <li>Document Your DSL - Document what each method does</li> </ol>"},{"location":"examples/building-dsl/#advanced-method-chaining","title":"Advanced: Method Chaining","text":"<p>Method chaining works naturally - methods can access state via <code>self</code>:</p> PythonGo <pre><code>class MusicDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.tracks = []\n        self.current_track = None\n\n    @method\n    def track(self, name):\n        self.current_track = {\"name\": name, \"clips\": []}\n        self.tracks.append(self.current_track)\n\n    @method\n    def add_clip(self, start, length):\n        if self.current_track:\n            self.current_track[\"clips\"].append({\n                \"start\": start,\n                \"length\": length\n            })\n</code></pre> <pre><code>func (d *MyDSL) Track(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    name := args[\"name\"].Str\n    action := gs.Action{\n        Kind: \"create_track\",\n        Payload: map[string]interface{}{\"name\": name},\n    }\n    newCtx := gs.NewContext()\n    newCtx.Set(\"track_name\", name)\n    return []gs.Action{action}, newCtx, nil\n}\n\nfunc (d *MyDSL) AddClip(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    trackName, _ := ctx.Get(\"track_name\")\n    action := gs.Action{\n        Kind: \"add_clip\",\n        Payload: map[string]interface{}{\n            \"track\":  trackName,\n            \"start\":  args[\"start\"].Num,\n            \"length\": args[\"length\"].Num,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n</code></pre>"},{"location":"examples/gpt-integration/","title":"GPT-5 Integration with Grammar School","text":"<p>This example demonstrates how to integrate Grammar School with GPT-5 using Context-Free Grammar (CFG) constraints.</p>"},{"location":"examples/gpt-integration/#overview","title":"Overview","text":"<p>Grammar School is designed to create LLM-friendly DSLs. When combined with GPT-5's CFG feature, you can ensure that the model generates only valid DSL code that can be executed by Grammar School.</p>"},{"location":"examples/gpt-integration/#key-features","title":"Key Features","text":"<ol> <li>CFG Constraint: Use Grammar School's Lark grammar definition as a CFG for GPT-5's custom tools</li> <li>Type Safety: GPT-5 can only generate syntactically valid DSL code</li> <li>Direct Execution: Generated code can be executed immediately without parsing errors</li> </ol>"},{"location":"examples/gpt-integration/#how-it-works","title":"How It Works","text":"<ol> <li>Grammar Definition: Grammar School uses Lark to define the DSL grammar</li> <li>CFG Export: The grammar can be exported and used as a CFG constraint in GPT-5</li> <li>Tool Definition: Define a GPT-5 custom tool with the grammar as a CFG</li> <li>Code Generation: GPT-5 generates DSL code that conforms to the grammar</li> <li>Execution: Execute the generated code using Grammar School's interpreter</li> </ol>"},{"location":"examples/gpt-integration/#example-usage","title":"Example Usage","text":"<pre><code>from grammar_school import Grammar, method\nfrom openai import OpenAI\n\nclass TaskGrammar(Grammar):\n    \"\"\"A simple task management DSL.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.tasks = {}\n\n    @method\n    def create_task(self, name: str, priority: str = \"medium\"):\n        \"\"\"Create a new task with a name and optional priority.\"\"\"\n        self.tasks[name] = {\"priority\": priority, \"completed\": False}\n        print(f\"\u2713 Created task: {name} (priority: {priority})\")\n\n    @method\n    def complete_task(self, name: str):\n        \"\"\"Mark a task as completed.\"\"\"\n        if name in self.tasks:\n            self.tasks[name][\"completed\"] = True\n            print(f\"\u2713 Completed task: {name}\")\n        else:\n            print(f\"\u2717 Task not found: {name}\")\n\n# Initialize Grammar School\ngrammar = TaskGrammar()\n\n# Use CFG provider to build OpenAI tool and generate DSL code\nfrom grammar_school.cfg_vendor import OpenAICFGProvider\nfrom grammar_school.openai_utils import OpenAICFG\n\n# Create CFG provider (OpenAI)\nprovider = OpenAICFGProvider()\n\n# Build the CFG tool payload\ncfg_tool = provider.build_tool(\n    tool_name=\"task_dsl\",\n    description=\"Executes task management operations using Grammar School DSL.\",\n    grammar=grammar.backend.grammar,  # Get grammar from Grammar instance\n    syntax=\"lark\",\n)\n\n# Get text format configuration (required for CFG)\ntext_format = provider.get_text_format()\n\n# Generate DSL code using OpenAI\nclient = OpenAI()\nresponse = client.chat.completions.create(\n    model=\"gpt-5\",\n    messages=[{\"role\": \"user\", \"content\": \"Create a task called 'Write docs' with high priority\"}],\n    tools=[cfg_tool],\n    tool_choice={\"type\": \"required\", \"tool\": {\"name\": \"task_dsl\"}},\n    **text_format,\n)\n\n# Extract DSL code from response\ndsl_code = provider.extract_dsl_code(response)\n\n# Execute the generated DSL code\nif dsl_code:\n    try:\n        grammar.execute(dsl_code)\n        print(\"Task created successfully!\")\n    except Exception as e:\n        print(f\"Error executing DSL: {e}\")\n</code></pre>"},{"location":"examples/gpt-integration/#benefits","title":"Benefits","text":"<ul> <li>Reliability: GPT-5 can only generate valid DSL code</li> <li>No Parsing Errors: Generated code is guaranteed to be syntactically correct</li> <li>Type Safety: The grammar enforces correct argument types and structure</li> <li>Easy Integration: Use Grammar School's existing grammar definitions</li> </ul>"},{"location":"examples/gpt-integration/#using-openai-cfg-the-simple-way","title":"Using OpenAI CFG - The Simple Way","text":"<p>For OpenAI, you can use the convenient <code>OpenAICFG</code> class:</p> <pre><code>from grammar_school.openai_utils import OpenAICFG\n\n# Create OpenAI CFG configuration\ncfg = OpenAICFG(\n    tool_name=\"task_dsl\",\n    description=\"Task management DSL\",\n    grammar=grammar.backend.grammar,  # Or use default Grammar School grammar\n)\n\n# Build tool and get text format\ntool = cfg.build_tool()\ntext_format = cfg.get_text_format()\n\n# Use with OpenAI client\nfrom openai import OpenAI\nclient = OpenAI()\nresponse = client.chat.completions.create(\n    model=\"gpt-5\",\n    messages=[{\"role\": \"user\", \"content\": \"Create a task\"}],\n    tools=[tool],\n    tool_choice={\"type\": \"required\", \"tool\": {\"name\": \"task_dsl\"}},\n    **text_format,\n)\n</code></pre> <p>The <code>OpenAICFG</code> class is a convenient wrapper that handles: - Building OpenAI CFG tool payloads - Configuring text format for CFG requests - Grammar cleaning (removing unsupported Lark directives)</p>"},{"location":"examples/gpt-integration/#using-cfg-providers","title":"Using CFG Providers","text":"<p>For more advanced use cases or to support multiple LLM providers, Grammar School provides a <code>CFGProvider</code> interface. The <code>OpenAICFGProvider</code> handles OpenAI-specific CFG integration:</p> <pre><code>from grammar_school.cfg_vendor import OpenAICFGProvider\nfrom grammar_school.openai_utils import OpenAICFG\n\n# Initialize your grammar\ngrammar = TaskGrammar()\n\n# Create CFG provider\nprovider = OpenAICFGProvider()\n\n# Build the CFG tool payload\ncfg_tool = provider.build_tool(\n    tool_name=\"task_dsl\",\n    description=\"Task management DSL\",\n    grammar=grammar.backend.grammar,\n    syntax=\"lark\",\n)\n\n# Get text format configuration\ntext_format = provider.get_text_format()\n\n# Use with OpenAI client\nfrom openai import OpenAI\nclient = OpenAI()\nresponse = client.chat.completions.create(\n    model=\"gpt-5\",\n    messages=[{\"role\": \"user\", \"content\": \"Create a task\"}],\n    tools=[cfg_tool],\n    tool_choice={\"type\": \"required\", \"tool\": {\"name\": \"task_dsl\"}},\n    **text_format,\n)\n\n# Extract and execute DSL code\ndsl_code = provider.extract_dsl_code(response)\nif dsl_code:\n    grammar.execute(dsl_code)\n</code></pre> <p>You can implement your own provider for other LLM providers:</p> <pre><code>from grammar_school.cfg_vendor import CFGProvider\n\nclass AnthropicCFGProvider(CFGProvider):\n    \"\"\"Custom vendor for Anthropic's Claude API.\"\"\"\n\n    def build_tool(self, tool_name, description, grammar, syntax):\n        # Implement vendor-specific tool structure\n        ...\n\n    def get_text_format(self):\n        # Return vendor-specific text format\n        ...\n\n    def generate(self, prompt, model, tools, text_format, client=None, **kwargs):\n        # Implement vendor-specific generation\n        ...\n\n    def extract_dsl_code(self, response):\n        # Extract DSL code from vendor response\n        ...\n</code></pre>"},{"location":"examples/gpt-integration/#requirements","title":"Requirements","text":"<ul> <li><code>grammar-school</code> package installed</li> <li><code>openai</code> Python SDK (version 1.99.2 or later)</li> <li>GPT-5 API access</li> <li><code>OPENAI_API_KEY</code> environment variable set</li> </ul>"},{"location":"examples/gpt-integration/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Install dependencies:    <pre><code>pip install grammar-school openai\n</code></pre></p> </li> <li> <p>Set your OpenAI API key:    <pre><code>export OPENAI_API_KEY=your-api-key-here\n</code></pre></p> </li> <li> <p>Run the example:    <pre><code>cd python\npython examples/gpt_integration.py\n</code></pre></p> </li> <li> <p>To test with GPT-5, uncomment the <code>integrate_with_gpt5()</code> call in the script.</p> </li> </ol>"},{"location":"examples/gpt-integration/#advanced-usage","title":"Advanced Usage","text":""},{"location":"examples/gpt-integration/#custom-grammar-definitions","title":"Custom Grammar Definitions","text":"<p>You can create custom grammar definitions for specific use cases:</p> <pre><code>from grammar_school import Grammar, rule\n\n@rule(\"\"\"\n    start: call_chain\n    call_chain: call ('.' call)*\n    call: IDENTIFIER '(' args? ')'\n    args: arg (',' arg)*\n    arg: IDENTIFIER '=' value\n    value: STRING | NUMBER\n    IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/\n    STRING: /\"[^\"]*\"/\n    NUMBER: /[0-9]+/\n\"\"\")\nclass CustomDSL(Grammar):\n    # Your DSL implementation\n    pass\n</code></pre>"},{"location":"examples/gpt-integration/#error-handling","title":"Error Handling","text":"<p>When GPT-5 generates code that fails to execute, you can provide feedback:</p> <pre><code>try:\n    grammar.execute(generated_code)\nexcept Exception as e:\n    # Send error back to GPT-5 for correction\n    feedback = f\"Error: {e}. Please fix the DSL code.\"\n    # Continue conversation with GPT-5\n</code></pre>"},{"location":"examples/gpt-integration/#see-also","title":"See Also","text":"<ul> <li>Grammar School Documentation</li> <li>GPT-5 CFG Documentation</li> <li>Lark Parser Documentation</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/","title":"JSON vs DSL: A Complete Walkthrough","text":"<p>This walkthrough demonstrates the fundamental difference between JSON/structured output and Domain-Specific Language (DSL) approaches when integrating LLMs with external data sources.</p> <p>Inspiration</p> <p>This walkthrough and the Grammar School library were partly inspired by Anthropic's article on Code execution with MCP: Building more efficient agents. The article explores how code execution enables agents to interact with MCP servers more efficiently by writing code instead of making direct tool calls, reducing token consumption and improving scalability.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#overview","title":"Overview","text":"<p>When building LLM applications that need to interact with data sources, developers have traditionally relied on structured output approaches. This typically involves:</p> <ul> <li>Using JSON schemas to constrain LLM responses</li> <li>Having the LLM call external services (like MCP servers) via function calling tools</li> <li>Allowing data to flow through the LLM context as it processes requests</li> </ul> <p>However, with the recent introduction of Context-Free Grammar (CFG) support in GPT-5 (OpenAI Cookbook), developers now have a powerful new option: Domain-Specific Languages (DSL).</p> <p>This new capability enables a fundamentally different approach:</p> <ol> <li>JSON/Structured Output (Traditional): LLM calls external services via tools, data flows through LLM context</li> <li>DSL with CFG (New): LLM generates code using CFG constraints, runtime executes it, data stays in runtime</li> </ol> <p>The key innovation is that CFG allows you to enforce strict syntax rules on the LLM's output, enabling it to generate valid code in your custom DSL that can be executed by a runtime environment. This opens up new possibilities for building scalable, cost-effective LLM applications.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#key-differences","title":"Key Differences","text":""},{"location":"examples/json-vs-dsl-walkthrough/#json-approach","title":"JSON Approach","text":"<ul> <li>Infrastructure: External services (MCP servers) MUST be publicly accessible</li> <li>Data Flow: <code>MCP Server (public) \u2192 LLM Context \u2192 JSON Output</code></li> <li>Token Usage: Grows linearly with data size (all data in LLM context)</li> <li>Latency: Increases with data size (data transfer through LLM)</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#dsl-approach","title":"DSL Approach","text":"<ul> <li>Infrastructure: External services can be local/private (no public URLs needed)</li> <li>Data Flow: <code>LLM \u2192 DSL Code \u2192 Runtime \u2192 MCP Server (local)</code></li> <li>Token Usage: Remains constant (no data in LLM context)</li> <li>Latency: More consistent (data doesn't flow through LLM)</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#example-user-data-processing","title":"Example: User Data Processing","text":"<p>Let's compare both approaches using a real-world scenario: fetching users, filtering them, and sending emails.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#scenario","title":"Scenario","text":"<ul> <li>Fetch N users from a database</li> <li>Filter to only include users older than 25</li> <li>Send notification emails to filtered users</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#json-approach-implementation","title":"JSON Approach Implementation","text":"<p><pre><code>class User(BaseModel):\n    \"\"\"User model for structured output.\"\"\"\n\n    name: str\n    age: int\n    email: str\n\n\nclass FilteredUsersResponse(BaseModel):\n    \"\"\"Response model for filtered users.\"\"\"\n\n    users: list[User]\n    count: int\n\n    try:\n        # LLM calls MCP via tools - MCP server MUST be publicly accessible\n        response = client.responses.parse(\n            model=model,\n            input=[\n                {\"role\": \"system\", \"content\": \"You are a data processing assistant.\"},\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            text_format=FilteredUsersResponse,\n            tools=[\n                {\n                    \"type\": \"mcp\",\n                    \"server_label\": \"user_database\",\n                    \"server_description\": \"A database MCP server for fetching and managing users.\",\n                    \"server_url\": f\"{mcp_public_url}/mcp\",  # MUST be public URL\n                    \"require_approval\": \"never\",\n                }\n            ],\n        )\n\n        result = response.output_parsed\n        usage = response.usage\n        elapsed_time = time.time() - start_time\n\n        # Inspect MCP tool calls in the response\n        print(\"\\n  MCP Tool Call Inspection:\")\n        # ... MCP inspection code ...\n    except Exception as e:\n        print(\"Error:\", e)\n</code></pre> What happens:</p> <ol> <li>LLM receives prompt</li> <li>LLM calls MCP server (public URL required)</li> <li>MCP returns 100 users \u2192 flows into LLM context</li> <li>LLM processes all 100 users in context</li> <li>LLM generates JSON with filtered results</li> </ol>"},{"location":"examples/json-vs-dsl-walkthrough/#dsl-approach-implementation","title":"DSL Approach Implementation","text":"<p><pre><code>class DataProcessingDSL(Grammar):\n    \"\"\"DSL for data processing - runtime handles MCP calls.\"\"\"\n\n    def __init__(self, mcp_local_url: str = \"http://localhost:8000\"):\n        super().__init__()\n        self.users: list[dict] = []\n        self.filtered_users: list[dict] = []\n        self.mcp_local_url = mcp_local_url\n\n    @method\n    def fetch_users(self, limit: int = 10):\n        \"\"\"\n        Fetch users - runtime calls MCP server directly.\n        MCP can be local/private because runtime calls it, not LLM.\n        \"\"\"\n        # Runtime calls MCP directly (can be localhost or private endpoint)\n        mcp_url = f\"{self.mcp_local_url}/mcp\"\n        mcp_data = call_mcp_local(mcp_url, limit=limit)\n        self.users = mcp_data.get(\"users\", [])\n        print(f\"  [Runtime] Fetched {len(self.users)} users from MCP (local)\")\n        return self\n\n    @method\n    def filter(self, *args, users=None, condition=None, **kwargs):  # noqa: ARG002\n        \"\"\"Filter users - simplified for basic grammar (no expressions).\"\"\"\n        # With basic grammar, we can't parse expressions like \"age &gt; 25\"\n        # So we hardcode the filter logic in runtime\n        # In production, you'd use advanced grammar with expressions\n        # Handle both positional and keyword arguments (including _positional from runtime)\n        # Ignore any unexpected kwargs (like _positional from interpreter)\n        self.filtered_users = [u for u in self.users if u.get(\"age\", 0) &gt; 25]\n        print(f\"  [Runtime] Filtered to {len(self.filtered_users)} users\")\n        return self\n\n    @method\n    def send_email(self, recipients=None, template=\"notification\"):\n        \"\"\"Send email - runtime calls MCP directly.\"\"\"\n        if recipients is None:\n            recipients = self.filtered_users\n        emails = [u[\"email\"] for u in recipients if isinstance(u, dict) and \"email\" in u]\n\n        # Runtime calls MCP directly (can be localhost - no public URL needed!)\n        try:\n            mcp_url = f\"{self.mcp_local_url}/mcp\"\n            asyncio.run(_call_mcp_send_email_local(mcp_url, emails, template))\n            print(f\"  [Runtime] Sending email to {len(emails)} recipients via MCP (local)\")\n        except Exception as e:\n            print(f\"  [Runtime] Email send failed: {e}\")\n        return self\n\n    # Measure latency\n    start_time = time.time()\n\n    try:\n        # Use CFG tool to generate DSL code\n        response = client.responses.create(\n            model=model,\n            input=[\n                {\"role\": \"system\", \"content\": \"You are a data processing assistant.\"},\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            text={\"format\": {\"type\": \"text\"}},\n            tools=[\n                {\n                    \"type\": \"custom\",\n                    \"name\": \"data_processing_dsl\",\n                    \"description\": (\n                        \"Executes data processing operations using Grammar School DSL. \"\n                        \"Available verbs: fetch_users(limit), filter(users, condition), send_email(recipients, template). \"\n                        \"YOU MUST REASON HEAVILY ABOUT THE QUERY AND MAKE SURE IT OBEYS THE GRAMMAR.\"\n                    ),\n                    \"format\": {\n                        \"type\": \"grammar\",\n                        \"syntax\": \"lark\",\n                        \"definition\": grammar_def,\n                    },\n                }\n            ],\n        )\n\n        # Extract DSL code from response\n        dsl_code = None\n        for item in response.output:\n            if hasattr(item, \"type\") and item.type == \"custom_tool_call\":\n                dsl_code = item.input\n                break\n\n        usage = response.usage\n\n        if dsl_code:\n            print(f\"\\n\u2713 Generated DSL code: {dsl_code}\")\n            print(\"  Token usage:\")\n            print(f\"    Input: {usage.input_tokens}\")\n            print(f\"    Output: {usage.output_tokens}\")\n            print(f\"    Total: {usage.total_tokens}\")\n\n            print(\"\\n  Executing DSL code in runtime...\")\n            runtime_start = time.time()\n\n            # Execute DSL code in runtime\n            dsl = DataProcessingDSL(mcp_local_url=mcp_local_url)\n            dsl.execute(dsl_code)\n\n            runtime_time = time.time() - runtime_start\n            total_time = time.time() - start_time\n\n            print(\"\\n  Latency:\")\n            print(f\"    LLM generation: {total_time - runtime_time:.2f}s\")\n            print(f\"    Runtime execution: {runtime_time:.2f}s\")\n            print(f\"    Total time: {total_time:.2f}s\")\n    except Exception as e:\n        print(\"Error:\", e)\n</code></pre> &lt;\uff5ctool\u2581call\u2581begin\uff5c&gt; run_terminal_cmd</p> <p>What happens:</p> <ol> <li>LLM receives prompt</li> <li>LLM generates DSL code (example shown below)</li> <li>Runtime executes DSL code</li> <li>Runtime calls external service (MCP server, REST API, or any HTTP endpoint - can be localhost)</li> <li>Runtime processes data locally</li> <li>No data flows through LLM context</li> </ol> <p>Example Generated DSL Code:</p> <p>For a prompt like \"Fetch 100 users, filter to those older than 25, and send them notification emails\", the LLM generates:</p> <pre><code>fetch_users(limit=100).filter().send_email()\n</code></pre> <p>Or with more explicit parameters:</p> <pre><code>fetch_users(limit=100).filter(condition=\"age &gt; 25\").send_email(template=\"notification\")\n</code></pre> <p>This DSL code is then executed by the runtime, which handles all the actual data fetching, filtering, and email sending without exposing any data to the LLM context.</p> <p>MCP vs REST API</p> <p>In this example, we use MCP (Model Context Protocol) for convenience, but MCP is not required for the DSL approach. The runtime can call any REST API, HTTP endpoint, or even local functions. The key advantage is that these services can be private/local, unlike the structured output approach where the LLM must be able to call them directly (requiring public URLs).</p>"},{"location":"examples/json-vs-dsl-walkthrough/#api-request-comparison","title":"API Request Comparison","text":"<p>The fundamental difference between the two approaches is visible in the OpenAI API request payloads. Here's a side-by-side comparison:</p>"},{"location":"examples/json-vs-dsl-walkthrough/#structured-output-json-request","title":"Structured Output (JSON) Request","text":"<pre><code>response = client.responses.parse(\n    model=model,\n    input=[...],\n    text_format=FilteredUsersResponse,  # Pydantic model \u2192 JSON schema\n    tools=[\n        {\n            \"type\": \"mcp\",\n            \"server_label\": \"user_database\",\n            \"server_description\": \"A database MCP server...\",\n            \"server_url\": f\"{mcp_public_url}/mcp\",  # MUST be public\n        }\n    ],\n)\n</code></pre> <p>Key Points:</p> <ul> <li><code>text_format</code>: Uses a Pydantic model (<code>FilteredUsersResponse</code>), which corresponds to <code>{\"type\": \"json\"}</code> with a JSON schema under the hood</li> <li><code>tools</code>: Defines MCP servers that the LLM can call to fetch data</li> <li>Data Flow: MCP returns data \u2192 flows into LLM context \u2192 LLM generates JSON matching the schema</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#dsl-cfg-request","title":"DSL (CFG) Request","text":"<pre><code>response = client.responses.create(\n    model=model,\n    input=[...],\n    text={\"format\": {\"type\": \"text\"}},  # Freeform text (default)\n    tools=[\n        {\n            \"type\": \"custom\",\n            \"name\": \"data_processing_dsl\",\n            \"description\": \"Executes data processing operations...\",\n            \"format\": {\n                \"type\": \"grammar\",\n                \"syntax\": \"lark\",\n                \"definition\": grammar_def,  # Full grammar definition\n            },\n        }\n    ],\n)\n</code></pre> <p>Key Points:</p> <ul> <li><code>text</code>: Uses freeform text format (default <code>{\"type\": \"text\"}</code>)</li> <li><code>tools</code>: Defines a custom tool with a grammar constraint (CFG) that enforces DSL syntax</li> <li>Data Flow: LLM generates DSL code \u2192 runtime executes \u2192 runtime calls MCP (no data in LLM context)</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#comparison-table","title":"Comparison Table","text":"Aspect Structured Output DSL with CFG API Method <code>responses.parse()</code> <code>responses.create()</code> Text Format <code>text_format=PydanticModel</code> \u2192 JSON schema <code>text={\"format\": {\"type\": \"text\"}}</code> (freeform) Tools Purpose Define MCP servers for LLM to call Define grammar constraints for code generation Tool Type <code>\"type\": \"mcp\"</code> <code>\"type\": \"custom\"</code> with <code>\"format\": {\"type\": \"grammar\"}</code> Grammar Overhead None (uses JSON schema) ~2,000+ tokens (full grammar definition) Data in Context Yes (all data from MCP flows through) No (only instructions, not data)"},{"location":"examples/json-vs-dsl-walkthrough/#performance-comparison","title":"Performance Comparison","text":""},{"location":"examples/json-vs-dsl-walkthrough/#token-usage","title":"Token Usage","text":"Users JSON Tokens DSL Tokens DSL Savings 10 1,848 2,853 -54.4% (JSON wins) 100 10,234 2,721 73.4% 1,000 27,111 2,662 90.2% 10,000 254,791 3,108 98.8% <p>Key Insights:</p> <ol> <li> <p>At Low Scale (10 users): JSON wins because the DSL approach includes the full grammar definition in the LLM context. This grammar overhead (~2,000+ tokens) exceeds the small amount of data (10 users) that would flow through JSON.</p> </li> <li> <p>At Scale (100+ users): DSL becomes dramatically more efficient because:</p> </li> <li>The grammar definition is a one-time cost that doesn't grow with data size</li> <li>JSON tokens grow linearly because all data flows through LLM context</li> <li> <p>DSL tokens remain constant because only instructions (not data) are in context</p> </li> <li> <p>The Crossover Point: Around 100 users, the grammar overhead is amortized and DSL's constant token usage becomes more efficient than JSON's linear growth.</p> </li> </ol>"},{"location":"examples/json-vs-dsl-walkthrough/#latency","title":"Latency","text":"Users JSON Latency DSL Latency Difference 10 10.32s 21.36s JSON faster (small overhead) 100 70.81s 24.67s DSL 2.9x faster 1,000 34.44s 21.06s DSL 1.6x faster 10,000 52.93s 30.32s DSL 1.7x faster <p>Latency Variability</p> <p>LLM latency can vary significantly between calls due to factors like model load, network conditions, and token generation complexity. However, we can observe a clear pattern: DSL latency remains relatively constant (21-30s range) regardless of data size, while JSON latency shows more variability and tends to increase with larger datasets. This consistency in DSL is because the LLM only generates code (constant complexity), while runtime execution happens locally and doesn't depend on LLM processing time.</p> <p>Key Insight: At scale, DSL latency is more consistent and often faster because data doesn't need to flow through the LLM.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#infrastructure-requirements","title":"Infrastructure Requirements","text":""},{"location":"examples/json-vs-dsl-walkthrough/#json-approach_1","title":"JSON Approach","text":"<pre><code>Requirements:\n  - MCP servers: Public URLs (HTTPS)\n  - Authentication: API keys required\n  - Network: Public internet access\n  - Security: Expose internal services publicly\n  - Cost: Higher token usage = higher costs\n</code></pre> <p>Example Setup: - Deploy MCP server to Railway/Heroku/AWS - Get public URL: <code>https://your-mcp-server.railway.app</code> - Configure CORS and authentication - Pay for all data tokens flowing through LLM</p>"},{"location":"examples/json-vs-dsl-walkthrough/#dsl-approach_1","title":"DSL Approach","text":"<pre><code>Requirements:\n  - External services: Can be local/private (REST API, MCP, or any HTTP endpoint)\n  - Authentication: Handled by runtime (not LLM)\n  - Network: Local network or VPN\n  - Security: Keep services private\n  - Cost: Lower token usage = lower costs\n</code></pre> <p>Example Setup: - Run service on localhost: <code>http://localhost:8000</code> (REST API, MCP, or any HTTP endpoint) - Or deploy to private network/VPN - No public exposure needed - Pay only for instruction generation tokens</p> <p>MCP Not Required</p> <p>While this example uses MCP for convenience, the DSL approach works with any REST API or HTTP endpoint. The runtime can call any service that your application has access to - it doesn't need to be MCP-compatible. This gives you maximum flexibility in choosing your backend services.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#effort-comparison-developer-llm-runtime-and-mcp","title":"Effort Comparison: Developer, LLM, Runtime, and MCP","text":"<p>This section breaks down where effort is required in each approach across four dimensions: developer effort, LLM effort, runtime effort, and MCP/server effort.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#structured-output-json-approach","title":"Structured Output (JSON) Approach","text":"Effort Type Description Examples Developer Effort Low - Define data models only Create Pydantic models (<code>User</code>, <code>FilteredUsersResponse</code>) LLM Effort High - Processes all data in context LLM receives 100 users, filters them, generates JSON response Runtime Effort Minimal - Just parse response Parse JSON from LLM response MCP/Server Effort Medium - Handles LLM requests MCP server receives requests from LLM, returns data, must be publicly accessible <p>Effort Distribution: - Developer: ~5% (data models) - LLM: ~85% (data processing, reasoning, generation) - Runtime: ~5% (parsing) - MCP/Server: ~5% (handling LLM requests)</p>"},{"location":"examples/json-vs-dsl-walkthrough/#dsl-approach_2","title":"DSL Approach","text":"Effort Type Description Examples Developer Effort Medium - Write runtime implementation Define grammar, implement <code>fetch_users()</code>, <code>filter()</code>, <code>send_email()</code> methods LLM Effort Low - Only generates code LLM generates <code>fetch_users(limit=100).filter().send_email()</code> Runtime Effort High - Parses AST and executes DSL code Runtime parses DSL into AST, executes code, calls MCP, processes data, handles errors, manages state MCP/Server Effort Medium - Handles runtime requests MCP server receives requests from runtime (can be local/private), returns data <p>Effort Distribution: - Developer: ~30% (grammar + runtime code) - LLM: ~20% (code generation only) - Runtime: ~35% (AST parsing, code execution, data processing, state management) - MCP/Server: ~15% (handling runtime requests)</p>"},{"location":"examples/json-vs-dsl-walkthrough/#comparison-summary","title":"Comparison Summary","text":"Aspect Structured Output DSL Developer writes Data models Grammar + Runtime code LLM does Data processing + Generation Code generation only Runtime does Parse JSON Parse AST + Execute DSL code + Process data + Manage state MCP/Server does Handle LLM requests (public) Handle runtime requests (can be private) Best for Quick prototypes, small datasets Production systems, large datasets <p>Key Insight: Structured output shifts effort to the LLM (which processes data), while DSL shifts effort to the developer (who writes runtime code) and runtime (which executes and processes data). The runtime in DSL does more work than the developer, handling execution, data processing, and state management. This trade-off makes DSL more efficient at scale because the LLM doesn't process data.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#developer-effort-comparison","title":"Developer Effort Comparison","text":""},{"location":"examples/json-vs-dsl-walkthrough/#structured-output-json","title":"Structured Output (JSON)","text":"<p>Setup Requirements: - Define Pydantic models (data schemas) - Deploy MCP server to public URL - Configure API authentication</p> <p>Code Required: - Data models only (e.g., <code>User</code>, <code>FilteredUsersResponse</code>) - Minimal boilerplate for API calls</p> <p>Example: <pre><code>class User(BaseModel):\n    name: str\n    age: int\n    email: str\n\nclass FilteredUsersResponse(BaseModel):\n    users: list[User]\n    count: int\n\n# That's it! The LLM handles the rest via MCP tools.\n</code></pre></p>"},{"location":"examples/json-vs-dsl-walkthrough/#dsl-approach_3","title":"DSL Approach","text":"<p>Setup Requirements: - Define grammar (syntax rules) - Write runtime implementation (verbs/methods) - Implement data processing logic - Handle MCP/API calls in runtime</p> <p>Code Required: - Grammar definition - Runtime class with method implementations - Data processing logic - Error handling - API/MCP integration code</p> <p>Example: <pre><code>class DataProcessingDSL(Grammar):\n    def __init__(self, mcp_local_url: str = \"http://localhost:8000\"):\n        super().__init__()\n        self.users: list[dict] = []\n        self.filtered_users: list[dict] = []\n        self.mcp_local_url = mcp_local_url\n\n    @method\n    def fetch_users(self, limit: int = 10):\n        # Runtime implementation - you write this\n        mcp_url = f\"{self.mcp_local_url}/mcp\"\n        mcp_data = call_mcp_local(mcp_url, limit=limit)\n        self.users = mcp_data.get(\"users\", [])\n        return self\n\n    @method\n    def filter(self, *args, **kwargs):\n        # Filter logic - you write this\n        self.filtered_users = [u for u in self.users if u.get(\"age\", 0) &gt; 25]\n        return self\n\n    @method\n    def send_email(self, recipients=None, template=\"notification\"):\n        # Email sending logic - you write this\n        # ... implementation ...\n        return self\n</code></pre></p> <p>Key Difference: - Structured Output: Define data models \u2192 LLM handles execution - DSL: Define grammar + write runtime code \u2192 You control execution</p>"},{"location":"examples/json-vs-dsl-walkthrough/#when-to-use-each-approach","title":"When to Use Each Approach","text":""},{"location":"examples/json-vs-dsl-walkthrough/#use-jsonstructured-output-when","title":"Use JSON/Structured Output When:","text":"<ul> <li>\u2705 Small datasets (&lt; 50 items)</li> <li>\u2705 Simple transformations</li> <li>\u2705 You need LLM reasoning on the data</li> <li>\u2705 Public APIs are acceptable</li> <li>\u2705 One-time queries</li> <li>\u2705 Latency is not critical</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#use-dsl-when","title":"Use DSL When:","text":"<ul> <li>\u2705 Latency is critical - DSL provides more consistent and often faster response times, especially at scale</li> <li>\u2705 Large datasets (&gt; 100 items)</li> <li>\u2705 Complex data processing pipelines</li> <li>\u2705 Data privacy is important</li> <li>\u2705 You want to keep services private</li> <li>\u2705 Recurring operations</li> <li>\u2705 Cost optimization is critical</li> </ul>"},{"location":"examples/json-vs-dsl-walkthrough/#running-the-comparison","title":"Running the Comparison","text":"<p>The complete comparison example is available in <code>python/examples/json_vs_dsl_comparison/</code>:</p> <pre><code>cd python\npython examples/json_vs_dsl_comparison/comparison.py\n</code></pre> <p>For detailed setup instructions, see the comparison README.</p>"},{"location":"examples/json-vs-dsl-walkthrough/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Latency: DSL provides more consistent and often faster response times, especially at scale - critical for latency-sensitive applications</p> </li> <li> <p>Token Efficiency: DSL becomes more efficient as data size increases (threshold ~100 items)</p> </li> <li> <p>Infrastructure: JSON requires public services; DSL can use private/local services</p> </li> <li> <p>Cost: DSL significantly reduces token costs for large datasets (up to 98.8% savings)</p> </li> <li> <p>Privacy: DSL keeps data in runtime, never exposing it to LLM context</p> </li> <li> <p>Scalability: DSL scales better because token usage remains constant regardless of data size</p> </li> </ol>"},{"location":"examples/json-vs-dsl-walkthrough/#conclusion","title":"Conclusion","text":"<p>The choice between JSON and DSL depends on your use case:</p> <ul> <li>Small scale, simple queries: JSON/structured output is simpler</li> <li>Large scale, complex pipelines: DSL is more efficient and cost-effective</li> <li>Privacy-sensitive data: DSL keeps data private</li> <li>Public APIs acceptable: JSON works fine</li> <li>Cost optimization: DSL saves significantly on tokens</li> </ul> <p>The DSL approach with Grammar School provides a powerful way to build scalable, cost-effective LLM applications that don't require exposing your data infrastructure publicly.</p>"},{"location":"examples/music-dsl/","title":"Music DSL Example","text":"<p>A complete example of building a music production DSL with Grammar School.</p>"},{"location":"examples/music-dsl/#overview","title":"Overview","text":"<p>This DSL allows you to create tracks, add clips, and apply effects using a simple syntax:</p> <pre><code>track(name=\"Drums\", color=\"blue\").add_clip(start=0, length=8)\ntrack(name=\"Bass\").add_clip(start=0, length=4).add_effect(name=\"reverb\", amount=0.5)\nCmaj7(1, 1), Fmaj7(2, 1), Gmaj7(3, 1)\n</code></pre>"},{"location":"examples/music-dsl/#python-implementation","title":"Python Implementation","text":"<pre><code>from grammar_school import Grammar, method\n\nclass MusicDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.tracks = []\n        self.current_track = None\n\n    @method\n    def track(self, name, color=None):\n        self.current_track = {\n            \"name\": name,\n            \"color\": color or \"default\",\n            \"clips\": [],\n            \"effects\": []\n        }\n        self.tracks.append(self.current_track)\n        print(f\"Created track: {name}\" + (f\" (color: {color})\" if color else \"\"))\n\n    @method\n    def add_clip(self, start, length):\n        if self.current_track:\n            self.current_track[\"clips\"].append({\n                \"start\": start,\n                \"length\": length\n            })\n            print(f\"Added clip: start={start}, length={length}\")\n\n    @method\n    def add_effect(self, name, amount=1.0):\n        if self.current_track:\n            self.current_track[\"effects\"].append({\n                \"name\": name,\n                \"amount\": amount\n            })\n            print(f\"Added effect: {name} (amount: {amount})\")\n\n# Usage\ndsl = MusicDSL()\n\ncode = '''\ntrack(name=\"Drums\", color=\"blue\").add_clip(start=0, length=8)\ntrack(name=\"Bass\").add_clip(start=0, length=4).add_effect(name=\"reverb\", amount=0.5)\n'''\n\ndsl.execute(code)\nprint(dsl.tracks)\n</code></pre>"},{"location":"examples/music-dsl/#go-implementation","title":"Go Implementation","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"grammar-school/go/gs\"\n)\n\ntype MusicDSL struct{}\n\nfunc (d *MusicDSL) Track(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    name := args[\"name\"].Str\n    color := \"default\"\n    if c, ok := args[\"color\"]; ok {\n        color = c.Str\n    }\n    action := gs.Action{\n        Kind: \"create_track\",\n        Payload: map[string]interface{}{\n            \"name\":  name,\n            \"color\": color,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n\nfunc (d *MusicDSL) AddClip(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    start := args[\"start\"].Num\n    length := args[\"length\"].Num\n    action := gs.Action{\n        Kind: \"add_clip\",\n        Payload: map[string]interface{}{\n            \"start\":  start,\n            \"length\": length,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n\ntype MusicRuntime struct {\n    tracks       []map[string]interface{}\n    currentTrack map[string]interface{}\n}\n\nfunc (r *MusicRuntime) ExecuteAction(ctx context.Context, a gs.Action) error {\n    switch a.Kind {\n    case \"create_track\":\n        r.currentTrack = map[string]interface{}{\n            \"name\":    a.Payload[\"name\"],\n            \"color\":   a.Payload[\"color\"],\n            \"clips\":   []interface{}{},\n            \"effects\": []interface{}{},\n        }\n        r.tracks = append(r.tracks, r.currentTrack)\n    case \"add_clip\":\n        if r.currentTrack != nil {\n            clips := r.currentTrack[\"clips\"].([]interface{})\n            clips = append(clips, map[string]interface{}{\n                \"start\":  a.Payload[\"start\"],\n                \"length\": a.Payload[\"length\"],\n            })\n            r.currentTrack[\"clips\"] = clips\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"examples/music-dsl/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ol> <li>Method Chaining - <code>track(...).add_clip(...).add_effect(...)</code></li> <li>State Management - Methods can access and modify state via <code>self</code> attributes</li> <li>Direct Execution - Methods execute directly when called</li> <li>Runtime State - The runtime maintains state across action executions</li> </ol>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":"<p>Grammar School follows a consistent conceptual model across all language implementations.</p>"},{"location":"getting-started/concepts/#the-pipeline","title":"The Pipeline","text":"<p>Every DSL program flows through this pipeline:</p> <pre><code>DSL Code (string)\n   \u2193\nParse \u2192 CallChain (AST)\n   \u2193\nInterpret \u2192 Execute methods directly\n</code></pre> <p>Note: Internally, Grammar School maintains a two-layer architecture (Grammar/Runtime), but this is hidden from users. Methods execute directly when called.</p>"},{"location":"getting-started/concepts/#dsl-program","title":"DSL Program","text":"<p>A DSL program is a plain string, typically generated by an LLM:</p> <pre><code>track(name=\"Drums\").add_clip(start=0, length=8)\nCmaj7(1,1), Fmaj7(2,1)\ntracks().filter(name~=\"FX\").mute()\n</code></pre>"},{"location":"getting-started/concepts/#abstract-syntax-tree-ast","title":"Abstract Syntax Tree (AST)","text":"<p>Grammar School uses a simple AST structure:</p> <ul> <li>Value: Represents a value (number, string, identifier, bool)</li> <li>Arg: A named argument with a value</li> <li>Call: A function call with named arguments</li> <li>CallChain: A chain of calls connected by dots (method chaining)</li> </ul>"},{"location":"getting-started/concepts/#example-ast","title":"Example AST","text":"<p>For the code <code>greet(name=\"Alice\", count=2)</code>:</p> <pre><code>CallChain\n  \u2514\u2500 Call(name=\"greet\")\n      \u251c\u2500 Arg(name=\"name\", value=Value(kind=\"string\", value=\"Alice\"))\n      \u2514\u2500 Arg(name=\"count\", value=Value(kind=\"number\", value=2))\n</code></pre>"},{"location":"getting-started/concepts/#methods","title":"Methods","text":"<p>Methods are DSL handlers that contain the actual implementation:</p> PythonGo <pre><code>class MusicDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.tracks = []\n\n    @method\n    def track(self, name, color=None):\n        track = {\"name\": name, \"color\": color}\n        self.tracks.append(track)\n        print(f\"Created track: {name}\")\n</code></pre> <pre><code>func (d *MyDSL) Track(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    name := args[\"name\"].Str\n    color := \"\"\n    if c, ok := args[\"color\"]; ok {\n        color = c.Str\n    }\n    action := gs.Action{\n        Kind: \"create_track\",\n        Payload: map[string]interface{}{\n            \"name\":  name,\n            \"color\": color,\n        },\n    }\n    return []gs.Action{action}, ctx, nil\n}\n</code></pre>"},{"location":"getting-started/concepts/#execution","title":"Execution","text":"<p>Methods execute directly when called - no Runtime needed:</p> PythonGo <pre><code>class MusicDSL(Grammar):\n    @method\n    def track(self, name):\n        # Implementation runs directly\n        print(f\"Created track: {name}\")\n\ndsl = MusicDSL()\ndsl.execute('track(name=\"Drums\")')  # Prints: Created track: Drums\n</code></pre> <pre><code>type MyRuntime struct{}\n\nfunc (r *MyRuntime) ExecuteAction(ctx context.Context, a gs.Action) error {\n    switch a.Kind {\n    case \"create_track\":\n        // Create a track...\n    }\n    return nil\n}\n</code></pre>"},{"location":"getting-started/concepts/#state-management","title":"State Management","text":"<p>State is managed using <code>self</code> attributes in your Grammar class:</p> PythonGo <pre><code>class MusicDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.tracks = []\n        self.current_track = None\n\n    @method\n    def track(self, name):\n        self.current_track = {\"name\": name}\n        self.tracks.append(self.current_track)\n\n    @method\n    def add_clip(self, start, length):\n        if self.current_track:\n            # Access state via self\n            self.current_track[\"clips\"].append({\"start\": start, \"length\": length})\n</code></pre> <pre><code>func (d *MyDSL) Track(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {\n    // ctx contains previous context\n    newCtx := gs.NewContext()\n    newCtx.Set(\"last_track\", name)\n    return []gs.Action{action}, newCtx, nil\n}\n</code></pre>"},{"location":"getting-started/concepts/#grammar","title":"Grammar","text":"<p>Grammars define the syntax of your DSL. Grammar School provides a default grammar, but you can customize it:</p> PythonGo <pre><code>custom_grammar = \"\"\"\nstart: call_chain\ncall_chain: call ('.' call)*\n# ... more rules\n\"\"\"\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL(grammar=custom_grammar)\n</code></pre> <pre><code>customGrammar := `\nstart: call_chain\ncall_chain: call ('.' call)*\n// ... more rules\n`\nengine, _ := gs.NewEngine(customGrammar, dsl, parser)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install Grammar School for your preferred language.</p>"},{"location":"getting-started/installation/#python","title":"Python","text":""},{"location":"getting-started/installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install grammar-school\n</code></pre>"},{"location":"getting-started/installation/#with-development-dependencies","title":"With Development Dependencies","text":"<pre><code>pip install grammar-school[dev]\n</code></pre>"},{"location":"getting-started/installation/#with-documentation-dependencies","title":"With Documentation Dependencies","text":"<pre><code>pip install grammar-school[docs]\n</code></pre>"},{"location":"getting-started/installation/#from-source-development","title":"From Source (Development)","text":"<pre><code>cd python\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li><code>lark&gt;=1.1.0</code> (parsing library)</li> </ul>"},{"location":"getting-started/installation/#go","title":"Go","text":""},{"location":"getting-started/installation/#installation_1","title":"Installation","text":"<pre><code>cd go\ngo mod download\n</code></pre>"},{"location":"getting-started/installation/#requirements_1","title":"Requirements","text":"<ul> <li>Go 1.21 or higher</li> </ul>"},{"location":"getting-started/installation/#using-in-your-project","title":"Using in Your Project","text":"<pre><code>go get github.com/Conceptual-Machines/grammar-school/go/gs\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"PythonGo <pre><code>import grammar_school\nprint(grammar_school.__version__)\n</code></pre> <pre><code>import \"grammar-school/go/gs\"\n// Check that package imports successfully\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with Grammar School in minutes.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"PythonGo <pre><code>pip install grammar-school\n</code></pre> <pre><code>cd go\ngo mod download\n</code></pre>"},{"location":"getting-started/quick-start/#your-first-dsl","title":"Your First DSL","text":"<p>Let's create a simple greeting DSL that demonstrates the core concepts.</p> PythonGo <pre><code>from grammar_school import Grammar, method\n\nclass GreetingDSL(Grammar):\n    @method\n    def greet(self, name, message=\"Hello\"):\n        print(f\"{message}, {name}!\")\n\n# Use the DSL\ndsl = GreetingDSL()\ndsl.execute('greet(name=\"Alice\")')\n# Output: Hello, Alice!\n\ndsl.execute('greet(name=\"Bob\", message=\"Hi\")')\n# Output: Hi, Bob!\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"grammar-school/go/gs\"\n)\n\ntype GreetingDSL struct{}\n\nfunc (d *GreetingDSL) Greet(args gs.Args) error {\n    name := args[\"name\"].Str\n    message := \"Hello\"\n    if msg, ok := args[\"message\"]; ok {\n        message = msg.Str\n    }\n    fmt.Printf(\"%s, %s!\\n\", message, name)\n    return nil\n}\n\nfunc main() {\n    dsl := &amp;GreetingDSL{}\n    parser := &amp;MyParser{} // Implement gs.Parser interface\n    engine, _ := gs.NewEngine(\"\", dsl, parser)\n    engine.Execute(context.Background(), `greet(name=\"Alice\")`)\n    // Output: Hello, Alice!\n    engine.Execute(context.Background(), `greet(name=\"Bob\", message=\"Hi\")`)\n    // Output: Hi, Bob!\n}\n</code></pre>"},{"location":"getting-started/quick-start/#how-it-works","title":"How It Works","text":"<ol> <li>Define Methods - Create methods marked with <code>@method</code> (Python) that contain your implementation</li> <li>Create Grammar - Instantiate your Grammar class (Python) or Engine (Go) with your DSL</li> <li>Execute - Parse and execute DSL code - methods run directly when called</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Core Concepts</li> <li>Explore the Python API or Go API</li> <li>Check out Examples</li> </ul>"},{"location":"go/api-reference/","title":"Go API Reference","text":"<p>Complete API reference for the Grammar School Go implementation.</p>"},{"location":"go/api-reference/#core-types","title":"Core Types","text":""},{"location":"go/api-reference/#value-and-valuekind","title":"Value and ValueKind","text":"<pre><code>type ValueKind int\n\nconst (\n    ValueNumber ValueKind = iota\n    ValueString\n    ValueIdentifier\n    ValueBool\n)\n\ntype Value struct {\n    Kind ValueKind\n    Num  float64\n    Str  string\n    Bool bool\n}\n</code></pre>"},{"location":"go/api-reference/#arg","title":"Arg","text":"<pre><code>type Arg struct {\n    Name  string\n    Value Value\n}\n</code></pre>"},{"location":"go/api-reference/#call","title":"Call","text":"<pre><code>type Call struct {\n    Name string\n    Args []Arg\n}\n</code></pre>"},{"location":"go/api-reference/#callchain","title":"CallChain","text":"<pre><code>type CallChain struct {\n    Calls []Call\n}\n</code></pre>"},{"location":"go/api-reference/#action","title":"Action","text":"<pre><code>type Action struct {\n    Kind    string\n    Payload map[string]interface{}\n}\n</code></pre>"},{"location":"go/api-reference/#context","title":"Context","text":"<pre><code>type Context struct {\n    Data map[string]interface{}\n}\n\nfunc NewContext() *Context\nfunc (c *Context) Get(key string) (interface{}, bool)\nfunc (c *Context) Set(key string, value interface{})\n</code></pre>"},{"location":"go/api-reference/#args","title":"Args","text":"<pre><code>type Args map[string]Value\n</code></pre>"},{"location":"go/api-reference/#engine","title":"Engine","text":"<pre><code>type Engine struct {\n    grammar string\n    parser  Parser\n    verbs   map[string]VerbHandler\n    dsl     interface{}\n}\n\nfunc NewEngine(grammar string, dsl interface{}, parser Parser) (*Engine, error)\nfunc (e *Engine) Compile(code string) ([]Action, error)\nfunc (e *Engine) Execute(ctx context.Context, runtime Runtime, plan []Action) error\n</code></pre>"},{"location":"go/api-reference/#parser-interface","title":"Parser Interface","text":"<pre><code>type Parser interface {\n    Parse(input string) (*CallChain, error)\n}\n</code></pre>"},{"location":"go/api-reference/#runtime-interface","title":"Runtime Interface","text":"<pre><code>type Runtime interface {\n    ExecuteAction(ctx context.Context, a Action) error\n}\n</code></pre>"},{"location":"go/api-reference/#methodhandler","title":"MethodHandler","text":"<pre><code>type MethodHandler func(args Args) error\n</code></pre> <p>Method handlers must match this signature. The Engine uses reflection to automatically discover and register methods with this signature. Methods execute directly - no Action return needed.</p>"},{"location":"go/api-reference/#openai-cfg-utilities","title":"OpenAI CFG Utilities","text":"<p>Grammar School provides utilities for integrating with OpenAI's Context-Free Grammar (CFG) feature, allowing you to use Grammar School grammars as constraints for GPT-5.</p>"},{"location":"go/api-reference/#cfgconfig","title":"CFGConfig","text":"<pre><code>type CFGConfig struct {\n    ToolName    string // Name of the tool that will receive the DSL output\n    Description string // Description of what the tool does\n    Grammar     string // Lark or regex grammar definition\n    Syntax      string // \"lark\" or \"regex\" (default: \"lark\")\n}\n</code></pre> <p>Configuration for building an OpenAI CFG tool.</p>"},{"location":"go/api-reference/#buildopenaicfgtool","title":"BuildOpenAICFGTool","text":"<pre><code>func BuildOpenAICFGTool(config CFGConfig) map[string]any\n</code></pre> <p>Builds an OpenAI CFG tool payload from a CFGConfig. This function: - Cleans the grammar using <code>CleanGrammarForCFG()</code> to remove unsupported Lark directives - Returns the properly formatted OpenAI tool structure - Ensures the syntax defaults to \"lark\" if not specified</p> <p>Example:</p> <pre><code>import \"grammar-school/go/gs\"\n\ntool := gs.BuildOpenAICFGTool(gs.CFGConfig{\n    ToolName:    \"magda_dsl\",\n    Description: \"Generates MAGDA DSL code for REAPER automation\",\n    Grammar:     grammarString,\n    Syntax:      gs.SyntaxLark,\n})\n// Add tool to OpenAI request: tools = append(tools, tool)\n</code></pre>"},{"location":"go/api-reference/#getopenaitextformatforcfg","title":"GetOpenAITextFormatForCFG","text":"<pre><code>func GetOpenAITextFormatForCFG() map[string]any\n</code></pre> <p>Returns the text format configuration that should be used when making OpenAI requests with CFG tools. When using CFG, the text format must be set to \"text\" (not JSON schema) because the output is DSL code, not JSON.</p> <p>Example:</p> <pre><code>paramsMap[\"text\"] = gs.GetOpenAITextFormatForCFG()\n</code></pre>"},{"location":"go/api-reference/#constants","title":"Constants","text":"<pre><code>const (\n    SyntaxLark     = \"lark\"   // Default syntax for CFG grammars\n    SyntaxRegex    = \"regex\"  // Regex syntax for CFG grammars\n    TextFormatType = \"text\"   // Text format type for OpenAI CFG requests\n)\n</code></pre>"},{"location":"go/api-reference/#cleangrammarforcfg","title":"CleanGrammarForCFG","text":"<pre><code>func CleanGrammarForCFG(grammar string) string\n</code></pre> <p>Cleans a grammar string for use with CFG systems (e.g., GPT-5). Removes parser-specific directives that aren't supported in standard CFG: - Lines starting with <code>%</code> (Lark directives like <code>%import</code>, <code>%ignore</code>) - Empty lines for cleaner output - Other parser-specific meta-directives</p>"},{"location":"go/api-reference/#cfgprovider-interface","title":"CFGProvider Interface","text":"<p>Grammar School provides a <code>CFGProvider</code> interface for integrating with different LLM providers that support CFG. This allows you to use the same API with different LLM providers.</p> <pre><code>type CFGProvider interface {\n    BuildTool(toolName, description, grammar, syntax string) map[string]any\n    GetTextFormat() map[string]any\n    Generate(ctx context.Context, prompt, model string, tools []map[string]any, textFormat map[string]any, client interface{}, kwargs map[string]any) (interface{}, error)\n    ExtractDSLCode(response interface{}) (string, error)\n}\n</code></pre>"},{"location":"go/api-reference/#openaicfgprovider","title":"OpenAICFGProvider","text":"<pre><code>import \"grammar-school/go/gs\"\n\nprovider := &amp;gs.OpenAICFGProvider{}\ncfgTool := provider.BuildTool(\n    \"task_dsl\",\n    \"Task management DSL\",\n    grammarString,\n    gs.SyntaxLark,\n)\ntextFormat := provider.GetTextFormat()\n</code></pre> <p>The <code>OpenAICFGProvider</code> struct implements the <code>CFGProvider</code> interface for OpenAI's API. It handles: - Building OpenAI-specific CFG tool payloads - Configuring text format for CFG requests - Generating DSL code using OpenAI's API - Extracting DSL code from OpenAI responses</p> <p>Example:</p> <pre><code>import (\n    \"context\"\n    \"grammar-school/go/gs\"\n    \"github.com/openai/openai-go\"\n)\n\nprovider := &amp;gs.OpenAICFGProvider{}\ncfgTool := provider.BuildTool(\n    \"task_dsl\",\n    \"Task management DSL\",\n    engine.Grammar(),\n    gs.SyntaxLark,\n)\ntextFormat := provider.GetTextFormat()\n\n// Use with OpenAI client\n// ... (OpenAI API call) ...\n\ndslCode, _ := provider.ExtractDSLCode(response)\nengine.Execute(ctx, dslCode)\n</code></pre>"},{"location":"go/core-types/","title":"Go Core Types","text":"<p>Detailed documentation of core types in the Grammar School Go implementation.</p>"},{"location":"go/core-types/#ast-types","title":"AST Types","text":""},{"location":"go/core-types/#value-and-valuekind","title":"Value and ValueKind","text":"<p>Represents a value in the AST with its kind.</p> <pre><code>type ValueKind int\n\nconst (\n    ValueNumber ValueKind = iota\n    ValueString\n    ValueIdentifier\n    ValueBool\n)\n\ntype Value struct {\n    Kind ValueKind\n    Num  float64\n    Str  string\n    Bool bool\n}\n</code></pre> <p>Example: <pre><code>value := Value{\n    Kind: ValueString,\n    Str:  \"hello\",\n}\n</code></pre></p>"},{"location":"go/core-types/#arg","title":"Arg","text":"<p>Represents a named argument to a call.</p> <pre><code>type Arg struct {\n    Name  string\n    Value Value\n}\n</code></pre> <p>Example: <pre><code>arg := Arg{\n    Name:  \"name\",\n    Value: Value{Kind: ValueString, Str: \"Alice\"},\n}\n</code></pre></p>"},{"location":"go/core-types/#call","title":"Call","text":"<p>Represents a single function call with named arguments.</p> <pre><code>type Call struct {\n    Name string\n    Args []Arg\n}\n</code></pre> <p>Example: <pre><code>call := Call{\n    Name: \"greet\",\n    Args: []Arg{\n        {Name: \"name\", Value: Value{Kind: ValueString, Str: \"Alice\"}},\n    },\n}\n</code></pre></p>"},{"location":"go/core-types/#callchain","title":"CallChain","text":"<p>Represents a chain of calls connected by dots (method chaining).</p> <pre><code>type CallChain struct {\n    Calls []Call\n}\n</code></pre> <p>Example: <pre><code>chain := CallChain{\n    Calls: []Call{\n        {Name: \"track\", Args: []Arg{}},\n        {Name: \"add_clip\", Args: []Arg{}},\n    },\n}\n</code></pre></p>"},{"location":"go/core-types/#method-handlers","title":"Method Handlers","text":"<p>Methods execute directly - no Action return needed. See the MethodHandler section below.</p>"},{"location":"go/core-types/#args","title":"Args","text":"<p>Map of string to Value for method handler arguments.</p> <pre><code>type Args map[string]Value\n</code></pre> <p>Example: <pre><code>args := Args{\n    \"name\":  Value{Kind: ValueString, Str: \"Alice\"},\n    \"count\": Value{Kind: ValueNumber, Num: 2},\n}\n</code></pre></p>"},{"location":"go/core-types/#method-handlers_1","title":"Method Handlers","text":""},{"location":"go/core-types/#methodhandler","title":"MethodHandler","text":"<p>Function signature for method handlers. Methods execute directly - no Action return needed.</p> <pre><code>type MethodHandler func(args Args) error\n</code></pre> <p>Example: <pre><code>func (d *MyDSL) Greet(args Args) error {\n    name := args[\"name\"].Str\n    fmt.Printf(\"Hello, %s!\\n\", name)\n    return nil\n}\n</code></pre></p> <p>Note: The <code>Action</code>, <code>Context</code>, and <code>Runtime</code> types still exist internally for the two-layer architecture, but users don't need to interact with them directly when using the unified interface.</p>"},{"location":"go/engine/","title":"Engine","text":"<p>The Engine orchestrates parsing, interpretation, and execution in the Go implementation.</p>"},{"location":"go/engine/#overview","title":"Overview","text":"<p>The <code>Engine</code> is the main entry point for Grammar School in Go. It manages the parser, method handlers, and execution flow.</p>"},{"location":"go/engine/#creating-an-engine","title":"Creating an Engine","text":"<pre><code>dsl := &amp;MyDSL{}\nparser := &amp;MyParser{}  // You need to implement Parser interface\nengine, err := gs.NewEngine(\"\", dsl, parser)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"go/engine/#executing-dsl-code","title":"Executing DSL Code","text":"<p>The <code>Execute</code> method parses and executes DSL code by calling methods directly:</p> <pre><code>err := engine.Execute(context.Background(), `greet(name=\"World\")`)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"go/engine/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"grammar-school/go/gs\"\n)\n\ntype MyDSL struct{}\n\nfunc (d *MyDSL) Greet(args gs.Args) error {\n    name := args[\"name\"].Str\n    fmt.Printf(\"Hello, %s!\\n\", name)\n    return nil\n}\n\nfunc main() {\n    dsl := &amp;MyDSL{}\n    parser := &amp;MyParser{} // Implement gs.Parser interface\n    engine, _ := gs.NewEngine(\"\", dsl, parser)\n    engine.Execute(context.Background(), `greet(name=\"World\")`)\n    // Output: Hello, World!\n}\n</code></pre>"},{"location":"go/engine/#method-discovery","title":"Method Discovery","text":"<p>The Engine uses reflection to automatically discover method handlers. A method is considered a handler if it matches this signature:</p> <pre><code>func (d *MyDSL) MethodName(args gs.Args) error\n</code></pre> <p>The Engine will automatically register all methods with this signature. Methods execute directly when called - no Action return needed.</p>"},{"location":"go/engine/#custom-grammar","title":"Custom Grammar","text":"<p>You can provide a custom grammar string:</p> <pre><code>customGrammar := `\nstart: call_chain\ncall_chain: call ('.' call)*\n// ... more rules\n`\nengine, err := gs.NewEngine(customGrammar, dsl, parser)\n</code></pre>"},{"location":"go/overview/","title":"Go API Overview","text":"<p>The Go implementation of Grammar School uses reflection to automatically discover method handlers.</p>"},{"location":"go/overview/#quick-example","title":"Quick Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"grammar-school/go/gs\"\n)\n\ntype MyDSL struct{}\n\nfunc (d *MyDSL) Greet(args gs.Args) error {\n    name := args[\"name\"].Str\n    fmt.Printf(\"Hello, %s!\\n\", name)\n    return nil\n}\n\nfunc main() {\n    dsl := &amp;MyDSL{}\n    parser := &amp;MyParser{} // Implement gs.Parser interface\n    engine, _ := gs.NewEngine(\"\", dsl, parser)\n    engine.Execute(context.Background(), `greet(name=\"World\")`)\n    // Output: Hello, World!\n}\n</code></pre>"},{"location":"go/overview/#key-components","title":"Key Components","text":""},{"location":"go/overview/#engine","title":"Engine","text":"<p>The <code>Engine</code> orchestrates parsing, interpretation, and execution:</p> <pre><code>engine, err := gs.NewEngine(grammar, dsl, parser)\n</code></pre>"},{"location":"go/overview/#method-handlers","title":"Method Handlers","text":"<p>Method handlers must match this signature:</p> <pre><code>func (d *MyDSL) MethodName(args gs.Args) error\n</code></pre> <p>The Engine uses reflection to automatically discover and register methods with this signature. Methods execute directly when called - no Action return needed.</p>"},{"location":"go/overview/#core-types","title":"Core Types","text":"<ul> <li><code>Value</code> / <code>ValueKind</code> - AST value node</li> <li><code>Arg</code> - Named argument</li> <li><code>Call</code> - Function call</li> <li><code>CallChain</code> - Chain of calls</li> <li><code>Args</code> - Map of string to Value</li> <li><code>Parser</code> - Pluggable parser interface</li> </ul>"},{"location":"go/overview/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Core Types - Detailed type information</li> <li>Engine - Engine usage guide</li> </ul>"},{"location":"go/runtime/","title":"Runtime (Internal Architecture)","text":"<p>Note: With the unified interface, you don't need to implement Runtime. Methods execute directly. This page documents the internal architecture for advanced users.</p>"},{"location":"go/runtime/#overview","title":"Overview","text":"<p>Internally, Grammar School maintains a two-layer architecture: 1. Grammar layer: Parses DSL and calls methods 2. Runtime layer: Executes methods (handled automatically)</p> <p>When using the unified interface, the Runtime layer is handled automatically - you just write methods with their implementation.</p>"},{"location":"go/runtime/#using-methods-recommended","title":"Using Methods (Recommended)","text":"<p>With the unified interface, you don't need Runtime:</p> <pre><code>type MyDSL struct {\n    tracks []map[string]interface{}\n    currentTrack map[string]interface{}\n}\n\nfunc (d *MyDSL) Track(args gs.Args) error {\n    name := args[\"name\"].Str\n    d.currentTrack = map[string]interface{}{\n        \"name\":  name,\n        \"clips\": []interface{}{},\n    }\n    d.tracks = append(d.tracks, d.currentTrack)\n    fmt.Printf(\"Created track: %s\\n\", name)\n    return nil\n}\n\nfunc (d *MyDSL) AddClip(args gs.Args) error {\n    start := args[\"start\"].Num\n    length := args[\"length\"].Num\n    if d.currentTrack != nil {\n        clips := d.currentTrack[\"clips\"].([]interface{})\n        clips = append(clips, map[string]interface{}{\n            \"start\":  start,\n            \"length\": length,\n        })\n        d.currentTrack[\"clips\"] = clips\n    }\n    return nil\n}\n\n// Usage\ndsl := &amp;MyDSL{}\nengine, _ := gs.NewEngine(\"\", dsl, parser)\nengine.Execute(context.Background(), `track(name=\"Drums\").add_clip(start=0, length=8)`)\n</code></pre>"},{"location":"go/runtime/#internal-architecture","title":"Internal Architecture","text":"<p>The <code>Runtime</code> interface still exists internally, but is handled automatically when using methods. The framework: 1. Parses DSL code 2. Calls your method handlers directly 3. Methods execute immediately</p> <p>You can manage state using struct fields in your DSL struct.</p>"},{"location":"python/api-reference/","title":"Python API Reference","text":"<p>Complete API reference for the Grammar School Python implementation.</p>"},{"location":"python/api-reference/#core-types","title":"Core Types","text":""},{"location":"python/api-reference/#grammar_school.ast.Value","title":"Value  <code>dataclass</code>","text":"<pre><code>Value(kind: str, value: Any)\n</code></pre> <p>A value in the AST (number, string, identifier, etc.).</p>"},{"location":"python/api-reference/#grammar_school.ast.Value-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.ast.Value.kind","title":"kind  <code>instance-attribute</code>","text":"<pre><code>kind: str\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.Value.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.Value-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.ast.Arg","title":"Arg  <code>dataclass</code>","text":"<pre><code>Arg(name: str, value: Value | Expression | PropertyAccess)\n</code></pre> <p>A named argument to a call.</p>"},{"location":"python/api-reference/#grammar_school.ast.Arg-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.ast.Arg.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.Arg.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Value | Expression | PropertyAccess\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.Arg-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.ast.Call","title":"Call  <code>dataclass</code>","text":"<pre><code>Call(name: str, args: dict[str, Value | Expression | PropertyAccess])\n</code></pre> <p>A single function call with named arguments.</p>"},{"location":"python/api-reference/#grammar_school.ast.Call-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.ast.Call.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: dict[str, Value | Expression | PropertyAccess]\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.Call.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.Call-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.ast.CallChain","title":"CallChain  <code>dataclass</code>","text":"<pre><code>CallChain(calls: list[Call] | Iterator[Call] | Iterable[Call] | None = None)\n</code></pre> <p>A chain of calls connected by dots (method chaining).</p> <p>Can be initialized with a list, iterator, or any iterable of Call objects.</p> <p>Initialize CallChain with calls.</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>list[Call] | Iterator[Call] | Iterable[Call] | None</code> <p>List, iterator, or iterable of Call objects. If None, creates empty chain.</p> <code>None</code> Source code in <code>grammar-school-python/grammar_school/ast.py</code> <pre><code>def __init__(self, calls: list[Call] | Iterator[Call] | Iterable[Call] | None = None):\n    \"\"\"\n    Initialize CallChain with calls.\n\n    Args:\n        calls: List, iterator, or iterable of Call objects. If None, creates empty chain.\n    \"\"\"\n    if calls is None:\n        object.__setattr__(self, \"calls\", [])\n    elif isinstance(calls, list):\n        object.__setattr__(self, \"calls\", calls)\n    else:\n        # Convert iterator/iterable to list\n        object.__setattr__(self, \"calls\", list(calls))\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.CallChain-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.ast.CallChain.calls","title":"calls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calls: list[Call] = field(default_factory=list)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.ast.CallChain-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.ast.CallChain.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Call]\n</code></pre> <p>Make CallChain iterable.</p> Source code in <code>grammar-school-python/grammar_school/ast.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Call]:\n    \"\"\"Make CallChain iterable.\"\"\"\n    return iter(self.calls)\n</code></pre>"},{"location":"python/api-reference/#method-decorators","title":"Method Decorators","text":"<p>Note: The <code>Action</code> and <code>Runtime</code> types still exist internally for the two-layer architecture, but users don't need to interact with them directly when using the unified <code>@method</code> interface.</p>"},{"location":"python/api-reference/#grammar_school.grammar.method","title":"method","text":"<pre><code>method(func: Callable) -&gt; Callable\n</code></pre> <p>Decorator to mark a method as a direct implementation handler.</p> <p>Methods decorated with @method contain the actual implementation. The framework handles the Grammar/Runtime split internally.</p> Example <p>@method def greet(self, name):     print(f\"Hello, {name}!\")     # Can do anything here - side effects, state changes, etc.</p> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def method(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to mark a method as a direct implementation handler.\n\n    Methods decorated with @method contain the actual implementation.\n    The framework handles the Grammar/Runtime split internally.\n\n    Example:\n        @method\n        def greet(self, name):\n            print(f\"Hello, {name}!\")\n            # Can do anything here - side effects, state changes, etc.\n    \"\"\"\n    func._is_method = True  # type: ignore[attr-defined]\n    return func\n</code></pre>"},{"location":"python/api-reference/#grammar","title":"Grammar","text":""},{"location":"python/api-reference/#grammar_school.grammar.Grammar","title":"Grammar","text":"<pre><code>Grammar(grammar: str | GrammarBuilder | dict[str, Any] | Path | None = None, grammar_file: str | Path | None = None)\n</code></pre> <p>Main Grammar class for Grammar School.</p> <p>Subclass this and define @verb methods to create your DSL handlers. Then use parse(), compile(), or execute() to process DSL scripts.</p> <p>The Two-Layer Architecture:</p> <ol> <li>@verb methods (in Grammar subclass):</li> <li>Transform DSL syntax into Action data structures</li> <li>Pure functions - no side effects, just return Actions</li> <li> <p>Example: <code>track(name=\"Drums\")</code> \u2192 <code>Action(kind=\"create_track\", payload={...})</code></p> </li> <li> <p>Runtime (separate class):</p> </li> <li>Takes Actions and performs actual side effects</li> <li>Handles state management, I/O, database operations, etc.</li> <li>Example: Receives <code>Action(kind=\"create_track\", ...)</code> \u2192 creates actual track in system</li> </ol> <p>This separation allows: - Same Grammar to work with different Runtimes (testing vs production) - @verb methods to be testable without side effects - Runtime to manage state independently of Grammar logic</p> Example <pre><code>from grammar_school import Grammar, verb, Action\n\nclass MyGrammar(Grammar):\n    @verb\n    def greet(self, name, _context=None):\n        # Pure function - just returns Action, no side effects\n        return Action(kind=\"greet\", payload={\"name\": name})\n\n# Default runtime prints actions - no need to import Runtime!\ngrammar = MyGrammar()\ngrammar.execute('greet(name=\"World\")')\n\n# Or provide a custom runtime for actual behavior\nfrom grammar_school import Runtime\n\nclass MyRuntime(Runtime):\n    def __init__(self):\n        self.greetings = []  # Runtime manages state\n\n    def execute(self, action: Action) -&gt; None:\n        # This is where side effects happen\n        if action.kind == \"greet\":\n            name = action.payload[\"name\"]\n            self.greetings.append(name)\n            print(f\"Hello, {name}!\")\n\ngrammar = MyGrammar(runtime=MyRuntime())\ngrammar.execute('greet(name=\"World\")')\n</code></pre> <pre><code>    Initialize grammar with optional custom grammar definition.\n\n    Args:\n        grammar: Optional custom grammar. Can be:\n                - String (Lark grammar definition)\n                - GrammarBuilder instance\n                - Dict (grammar config - will be loaded via load_grammar_from_config)\n                - Path (to YAML/TOML grammar config file)\n                - None (uses Grammar School's default)\n        grammar_file: Optional path to YAML/TOML grammar config file (alternative to grammar)\n\n    Example:\n        ```python\n        # Using @method handlers - simple and direct\n        class MyDSL(Grammar):\n            @method\n            def greet(self, name):\n                print(f\"Hello, {name}!\")\n\n        dsl = MyDSL()  # No runtime needed\n        dsl.execute('greet(name=\"World\")')\n\n        # Using string\n        grammar = MyGrammar(grammar=\"start: call_chain\n</code></pre> <p>call_chain: call (DOT call)*\")</p> <pre><code>        # Using GrammarBuilder\n        from grammar_school import GrammarBuilder\n        builder = GrammarBuilder.default()\n        grammar = MyGrammar(grammar=builder)\n\n        # Using config dict\n        config = {\n            \"start\": \"start\",\n            \"rules\": [\n                {\"name\": \"start\", \"definition\": \"call_chain\"},\n                {\"name\": \"call_chain\", \"definition\": \"call (DOT call)*\"}\n            ]\n        }\n        grammar = MyGrammar(grammar=config)\n\n        # Using config file\n        grammar = MyGrammar(grammar_file=\"grammar.yaml\")\n        # or\n        grammar = MyGrammar(grammar=\"grammar.toml\")  # Path as string\n        ```\n</code></pre> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def __init__(\n    self,\n    grammar: str | GrammarBuilder | dict[str, Any] | Path | None = None,\n    grammar_file: str | Path | None = None,\n):\n    \"\"\"\n    Initialize grammar with optional custom grammar definition.\n\n    Args:\n        grammar: Optional custom grammar. Can be:\n                - String (Lark grammar definition)\n                - GrammarBuilder instance\n                - Dict (grammar config - will be loaded via load_grammar_from_config)\n                - Path (to YAML/TOML grammar config file)\n                - None (uses Grammar School's default)\n        grammar_file: Optional path to YAML/TOML grammar config file (alternative to grammar)\n\n    Example:\n        ```python\n        # Using @method handlers - simple and direct\n        class MyDSL(Grammar):\n            @method\n            def greet(self, name):\n                print(f\"Hello, {name}!\")\n\n        dsl = MyDSL()  # No runtime needed\n        dsl.execute('greet(name=\"World\")')\n\n        # Using string\n        grammar = MyGrammar(grammar=\"start: call_chain\\ncall_chain: call (DOT call)*\")\n\n        # Using GrammarBuilder\n        from grammar_school import GrammarBuilder\n        builder = GrammarBuilder.default()\n        grammar = MyGrammar(grammar=builder)\n\n        # Using config dict\n        config = {\n            \"start\": \"start\",\n            \"rules\": [\n                {\"name\": \"start\", \"definition\": \"call_chain\"},\n                {\"name\": \"call_chain\", \"definition\": \"call (DOT call)*\"}\n            ]\n        }\n        grammar = MyGrammar(grammar=config)\n\n        # Using config file\n        grammar = MyGrammar(grammar_file=\"grammar.yaml\")\n        # or\n        grammar = MyGrammar(grammar=\"grammar.toml\")  # Path as string\n        ```\n    \"\"\"\n\n    # Handle grammar parameter\n    if grammar is None:\n        if grammar_file is not None:\n            # Load from file\n            grammar_str = self._load_grammar_from_file(grammar_file)\n        else:\n            # Use default\n            grammar_str = DEFAULT_GRAMMAR\n    elif isinstance(grammar, dict):\n        # Config dict - load it\n        grammar_str = load_grammar_from_config(grammar)\n    elif isinstance(grammar, str | Path) and (\n        str(grammar).endswith(\".yaml\")\n        or str(grammar).endswith(\".yml\")\n        or str(grammar).endswith(\".toml\")\n    ):\n        # Path to config file\n        grammar_str = self._load_grammar_from_file(grammar)\n    elif isinstance(grammar, GrammarBuilder):\n        # GrammarBuilder - convert to string\n        grammar_str = grammar.build()\n    else:\n        # String (Lark grammar definition)\n        grammar_str = str(grammar)\n\n    self.backend = LarkBackend(grammar_str)\n    self.interpreter = Interpreter(self)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.Grammar-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.grammar.Grammar.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend = LarkBackend(grammar_str)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.Grammar.interpreter","title":"interpreter  <code>instance-attribute</code>","text":"<pre><code>interpreter = Interpreter(self)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.Grammar-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.grammar.Grammar.compile","title":"compile","text":"<pre><code>compile(code: str) -&gt; list[None]\n</code></pre> <p>Compile DSL code by executing methods.</p> <p>Note: Methods execute directly during compilation. Returns a list of None values (one per method call).</p> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def compile(self, code: str) -&gt; list[None]:\n    \"\"\"\n    Compile DSL code by executing methods.\n\n    Note: Methods execute directly during compilation.\n    Returns a list of None values (one per method call).\n    \"\"\"\n    call_chain = self.parse(code)\n    return self.interpreter.interpret(call_chain)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.Grammar.execute","title":"execute","text":"<pre><code>execute(code: str) -&gt; None\n</code></pre> <p>Execute DSL code by calling methods directly.</p> <p>Methods decorated with @method are executed immediately when called. No runtime is needed - methods contain their own implementation.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>DSL code string to execute</p> required Example <pre><code>class MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL()\ndsl.execute('greet(name=\"World\")')  # Prints: Hello, World!\n</code></pre> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def execute(self, code: str) -&gt; None:\n    \"\"\"\n    Execute DSL code by calling methods directly.\n\n    Methods decorated with @method are executed immediately when called.\n    No runtime is needed - methods contain their own implementation.\n\n    Args:\n        code: DSL code string to execute\n\n    Example:\n        ```python\n        class MyDSL(Grammar):\n            @method\n            def greet(self, name):\n                print(f\"Hello, {name}!\")\n\n        dsl = MyDSL()\n        dsl.execute('greet(name=\"World\")')  # Prints: Hello, World!\n        ```\n    \"\"\"\n    call_chain = self.parse(code)\n    # Execute methods directly - they run during interpretation\n    for _ in self.interpreter.interpret_stream(call_chain):\n        pass  # Methods execute during interpretation\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.Grammar.parse","title":"parse","text":"<pre><code>parse(code: str) -&gt; CallChain\n</code></pre> <p>Parse DSL code into a CallChain AST.</p> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def parse(self, code: str) -&gt; CallChain:\n    \"\"\"Parse DSL code into a CallChain AST.\"\"\"\n    return self.backend.parse(code)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.Grammar.stream","title":"stream","text":"<pre><code>stream(code: str)\n</code></pre> <p>Stream method executions from DSL code.</p> <p>This is a generator that executes methods one at a time, allowing for memory-efficient processing and real-time execution of large DSL programs.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>DSL code string to execute and stream</p> required <p>Yields:</p> Name Type Description <code>None</code> <p>One None per method executed (methods execute during iteration)</p> Example <pre><code>grammar = MyGrammar()\nfor _ in grammar.stream('greet(name=\"A\").greet(name=\"B\").greet(name=\"C\")'):\n    # Methods execute as they're called\n    pass\n</code></pre> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def stream(self, code: str):\n    \"\"\"\n    Stream method executions from DSL code.\n\n    This is a generator that executes methods one at a time, allowing\n    for memory-efficient processing and real-time execution of large DSL programs.\n\n    Args:\n        code: DSL code string to execute and stream\n\n    Yields:\n        None: One None per method executed (methods execute during iteration)\n\n    Example:\n        ```python\n        grammar = MyGrammar()\n        for _ in grammar.stream('greet(name=\"A\").greet(name=\"B\").greet(name=\"C\")'):\n            # Methods execute as they're called\n            pass\n        ```\n    \"\"\"\n    call_chain = self.parse(code)\n    yield from self.interpreter.interpret_stream(call_chain)\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.rule","title":"rule","text":"<pre><code>rule(grammar: str | None = None, **kwargs: str | Any) -&gt; Callable[[type[T]], type[T]]\n</code></pre> <p>Decorator to define grammar rules.</p> <p>Supports three forms: 1. @rule(\"call_chain: call ('.' call)\") 2. @rule(call_chain=\"call ('.' call)\") 3. @rule(call_chain = sym(\"call\") + many(lit(\".\") + sym(\"call\")))</p> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def rule(\n    grammar: str | None = None,\n    **kwargs: str | Any,\n) -&gt; Callable[[type[T]], type[T]]:\n    \"\"\"\n    Decorator to define grammar rules.\n\n    Supports three forms:\n    1. @rule(\"call_chain: call ('.' call)*\")\n    2. @rule(call_chain=\"call ('.' call)*\")\n    3. @rule(call_chain = sym(\"call\") + many(lit(\".\") + sym(\"call\")))\n    \"\"\"\n    if grammar is not None:\n\n        def decorator_with_grammar(cls: type[T]) -&gt; type[T]:\n            if not hasattr(cls, \"_grammar_rules\"):\n                cls._grammar_rules = {}  # type: ignore[attr-defined]\n            cls._grammar_rules[\"_default\"] = grammar  # type: ignore[attr-defined]\n            return cls\n\n        return decorator_with_grammar\n\n    def decorator_with_kwargs(cls: type[T]) -&gt; type[T]:\n        if not hasattr(cls, \"_grammar_rules\"):\n            cls._grammar_rules = {}  # type: ignore[attr-defined]\n        for key, value in kwargs.items():\n            cls._grammar_rules[key] = value  # type: ignore[attr-defined]\n        return cls\n\n    return decorator_with_kwargs\n</code></pre>"},{"location":"python/api-reference/#grammar_school.grammar.method","title":"method","text":"<pre><code>method(func: Callable) -&gt; Callable\n</code></pre> <p>Decorator to mark a method as a direct implementation handler.</p> <p>Methods decorated with @method contain the actual implementation. The framework handles the Grammar/Runtime split internally.</p> Example <p>@method def greet(self, name):     print(f\"Hello, {name}!\")     # Can do anything here - side effects, state changes, etc.</p> Source code in <code>grammar-school-python/grammar_school/grammar.py</code> <pre><code>def method(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to mark a method as a direct implementation handler.\n\n    Methods decorated with @method contain the actual implementation.\n    The framework handles the Grammar/Runtime split internally.\n\n    Example:\n        @method\n        def greet(self, name):\n            print(f\"Hello, {name}!\")\n            # Can do anything here - side effects, state changes, etc.\n    \"\"\"\n    func._is_method = True  # type: ignore[attr-defined]\n    return func\n</code></pre>"},{"location":"python/api-reference/#interpreter","title":"Interpreter","text":""},{"location":"python/api-reference/#grammar_school.interpreter.Interpreter","title":"Interpreter","text":"<pre><code>Interpreter(dsl_instance: Any)\n</code></pre> <p>Interprets CallChain AST and executes methods directly.</p> <p>Initialize interpreter with a DSL instance containing method handlers.</p> Source code in <code>grammar-school-python/grammar_school/interpreter.py</code> <pre><code>def __init__(self, dsl_instance: Any):\n    \"\"\"Initialize interpreter with a DSL instance containing method handlers.\"\"\"\n    self.dsl = dsl_instance\n    self._method_handlers = self._collect_methods()\n</code></pre>"},{"location":"python/api-reference/#grammar_school.interpreter.Interpreter-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.interpreter.Interpreter.dsl","title":"dsl  <code>instance-attribute</code>","text":"<pre><code>dsl = dsl_instance\n</code></pre>"},{"location":"python/api-reference/#grammar_school.interpreter.Interpreter-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.interpreter.Interpreter.interpret","title":"interpret","text":"<pre><code>interpret(call_chain: CallChain) -&gt; list[None]\n</code></pre> <p>Interpret a CallChain by executing methods directly.</p> <p>Note: This method exists for compatibility but methods execute directly during interpret_stream. The returned list will contain None values (one per method call executed).</p> Source code in <code>grammar-school-python/grammar_school/interpreter.py</code> <pre><code>def interpret(self, call_chain: CallChain) -&gt; list[None]:\n    \"\"\"\n    Interpret a CallChain by executing methods directly.\n\n    Note: This method exists for compatibility but methods execute directly\n    during interpret_stream. The returned list will contain None values\n    (one per method call executed).\n    \"\"\"\n    return list(self.interpret_stream(call_chain))\n</code></pre>"},{"location":"python/api-reference/#grammar_school.interpreter.Interpreter.interpret_stream","title":"interpret_stream","text":"<pre><code>interpret_stream(call_chain: CallChain)\n</code></pre> <p>Interpret a CallChain by executing methods directly (streaming).</p> <p>This is a generator that executes methods one at a time, allowing for memory-efficient processing of large DSL programs.</p> <p>Yields:</p> Name Type Description <code>None</code> <p>One None per method executed (for compatibility with Action-based interface)</p> Source code in <code>grammar-school-python/grammar_school/interpreter.py</code> <pre><code>def interpret_stream(self, call_chain: CallChain):\n    \"\"\"\n    Interpret a CallChain by executing methods directly (streaming).\n\n    This is a generator that executes methods one at a time, allowing\n    for memory-efficient processing of large DSL programs.\n\n    Yields:\n        None: One None per method executed (for compatibility with Action-based interface)\n    \"\"\"\n    for call in call_chain.calls:\n        if call.name not in self._method_handlers:\n            raise ValueError(f\"Unknown method: {call.name}\")\n\n        handler = self._method_handlers[call.name]\n        args = self._coerce_args(call.args)\n        # Remove _context from args if present (methods don't need it)\n        args.pop(\"_context\", None)\n        # Call method directly - it executes immediately\n        handler(**args)\n        # Yield None to indicate execution (for compatibility)\n        yield None\n</code></pre>"},{"location":"python/api-reference/#parser-backend","title":"Parser Backend","text":""},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend","title":"LarkBackend","text":"<pre><code>LarkBackend(grammar: str = DEFAULT_GRAMMAR, transformer: Transformer | None = None, use_smart_transformer: bool = True)\n</code></pre> <p>Lark-based parser backend.</p> <p>Initialize with a Lark grammar string.</p> <p>Parameters:</p> Name Type Description Default <code>grammar</code> <code>str</code> <p>Lark grammar string</p> <code>DEFAULT_GRAMMAR</code> <code>transformer</code> <code>Transformer | None</code> <p>Optional custom transformer (if None, uses SmartTransformer or ASTTransformer)</p> <code>None</code> <code>use_smart_transformer</code> <code>bool</code> <p>If True, use SmartTransformer (adapts to any grammar).                  If False, use ASTTransformer (coupled to default grammar).</p> <code>True</code> Source code in <code>grammar-school-python/grammar_school/backend_lark.py</code> <pre><code>def __init__(\n    self,\n    grammar: str = DEFAULT_GRAMMAR,\n    transformer: Transformer | None = None,\n    use_smart_transformer: bool = True,\n):\n    \"\"\"\n    Initialize with a Lark grammar string.\n\n    Args:\n        grammar: Lark grammar string\n        transformer: Optional custom transformer (if None, uses SmartTransformer or ASTTransformer)\n        use_smart_transformer: If True, use SmartTransformer (adapts to any grammar).\n                             If False, use ASTTransformer (coupled to default grammar).\n    \"\"\"\n    self.parser = Lark(grammar, start=\"start\", parser=\"lalr\")\n    if transformer is not None:\n        self.transformer = transformer\n    elif use_smart_transformer:\n        # SmartTransformer works with any grammar, including the default\n        self.transformer = SmartTransformer()\n    else:\n        # ASTTransformer is faster for default grammar (backward compatibility)\n        self.transformer = ASTTransformer()\n</code></pre>"},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend-attributes","title":"Attributes","text":""},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend.parser","title":"parser  <code>instance-attribute</code>","text":"<pre><code>parser = Lark(grammar, start='start', parser='lalr')\n</code></pre>"},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend.transformer","title":"transformer  <code>instance-attribute</code>","text":"<pre><code>transformer = transformer\n</code></pre>"},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend-functions","title":"Functions","text":""},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend.clean_grammar_for_cfg","title":"clean_grammar_for_cfg  <code>staticmethod</code>","text":"<pre><code>clean_grammar_for_cfg(grammar: str) -&gt; str\n</code></pre> <p>Clean Lark grammar for use with CFG systems (e.g., GPT-5).</p> <p>Removes Lark-specific directives that aren't supported in standard CFG: - %import directives - %ignore directives - Other %-prefixed directives</p> <p>Parameters:</p> Name Type Description Default <code>grammar</code> <code>str</code> <p>Lark grammar string with directives</p> required <p>Returns:</p> Type Description <code>str</code> <p>Cleaned grammar string suitable for CFG systems</p> Example <pre><code>cleaned = LarkBackend.clean_grammar_for_cfg(DEFAULT_GRAMMAR)\n# Use cleaned grammar with GPT-5 CFG\n</code></pre> Source code in <code>grammar-school-python/grammar_school/backend_lark.py</code> <pre><code>@staticmethod\ndef clean_grammar_for_cfg(grammar: str) -&gt; str:\n    \"\"\"\n    Clean Lark grammar for use with CFG systems (e.g., GPT-5).\n\n    Removes Lark-specific directives that aren't supported in standard CFG:\n    - %import directives\n    - %ignore directives\n    - Other %-prefixed directives\n\n    Args:\n        grammar: Lark grammar string with directives\n\n    Returns:\n        Cleaned grammar string suitable for CFG systems\n\n    Example:\n        ```python\n        cleaned = LarkBackend.clean_grammar_for_cfg(DEFAULT_GRAMMAR)\n        # Use cleaned grammar with GPT-5 CFG\n        ```\n    \"\"\"\n    return \"\\n\".join(line for line in grammar.split(\"\\n\") if not line.strip().startswith(\"%\"))\n</code></pre>"},{"location":"python/api-reference/#grammar_school.backend_lark.LarkBackend.parse","title":"parse","text":"<pre><code>parse(code: str) -&gt; CallChain\n</code></pre> <p>Parse code into a CallChain AST.</p> Source code in <code>grammar-school-python/grammar_school/backend_lark.py</code> <pre><code>def parse(self, code: str) -&gt; CallChain:\n    \"\"\"Parse code into a CallChain AST.\"\"\"\n    tree = self.parser.parse(code)\n    result = self.transformer.transform(tree)\n    # Handle case where transformer returns a list (unwrap it)\n    if isinstance(result, list):\n        if result and isinstance(result[0], CallChain):\n            return result[0]\n        # If list contains Calls, create a CallChain using iterator\n        from grammar_school.ast import Call\n\n        # Use generator expression instead of list comprehension for memory efficiency\n        calls_iter = (item for item in result if isinstance(item, Call))\n        calls = list(calls_iter)  # Convert to list for CallChain\n        if calls:\n            return CallChain(calls=calls)\n        # Empty list - return empty CallChain\n        return CallChain(calls=[])\n    # Result should be a CallChain\n    if isinstance(result, CallChain):\n        return result\n    # If it's a single Call, wrap it\n    from grammar_school.ast import Call\n\n    if isinstance(result, Call):\n        return CallChain(calls=[result])\n    # Fallback: return empty CallChain\n    return CallChain(calls=[])\n</code></pre>"},{"location":"python/api-reference/#grammar_school.backend_lark.DEFAULT_GRAMMAR","title":"DEFAULT_GRAMMAR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_GRAMMAR = '\\nstart: statement+\\n\\n// Statement is a call chain (which can be a single call or multiple chained calls)\\nstatement: call_chain\\n\\ncall_chain: call (DOT call)*\\ncall: IDENTIFIER \"(\" args? \")\"\\nargs: arg (COMMA arg)*\\narg: IDENTIFIER \"=\" expression\\n    | expression\\n\\n// Expression with operator precedence (lowest to highest)\\nexpression: comparison\\ncomparison: addition (comparison_op addition)*\\ncomparison_op: EQ | NE | LT | GT | LE | GE\\naddition: multiplication (add_op multiplication)*\\nadd_op: PLUS | MINUS\\nmultiplication: atom (mul_op atom)*\\nmul_op: MUL | DIV\\natom: NUMBER\\n    | STRING\\n    | BOOL\\n    | IDENTIFIER\\n    | property_access\\n    | function_ref\\n    | \"(\" expression \")\"\\n\\n// Property access: track.name\\nproperty_access: IDENTIFIER (DOT IDENTIFIER)+\\n\\n// Function reference: @function_name syntax\\nfunction_ref: \"@\" IDENTIFIER\\n\\n// Operators\\nPLUS: \"+\"\\nMINUS: \"-\"\\nMUL: \"*\"\\nDIV: \"/\"\\nEQ: \"==\"\\nNE: \"!=\"\\nLT: \"&lt;\"\\nGT: \"&gt;\"\\nLE: \"&lt;=\"\\nGE: \"&gt;=\"\\n\\nDOT: \".\"\\nCOMMA: \",\"\\nNUMBER: /-?\\\\d+(\\\\.\\\\d+)?/\\nSTRING: /\"([^\"\\\\\\\\]|\\\\\\\\.)*\"|\\'([^\\'\\\\\\\\]|\\\\\\\\.)*\\'/\\nIDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/\\nBOOL: \"true\" | \"false\"\\n\\n%import common.WS\\n%ignore WS\\n'\n</code></pre>"},{"location":"python/api-reference/#openai-cfg-utilities","title":"OpenAI CFG Utilities","text":"<p>Grammar School provides utilities for integrating with OpenAI's Context-Free Grammar (CFG) feature, allowing you to use Grammar School grammars as constraints for GPT-5.</p>"},{"location":"python/api-reference/#cfgconfig","title":"CFGConfig","text":"<pre><code>@dataclass\nclass CFGConfig:\n    tool_name: str\n    description: str\n    grammar: str\n    syntax: str = \"lark\"\n</code></pre> <p>Configuration for building an OpenAI CFG tool.</p> <p>Example:</p> <pre><code>from grammar_school.openai_utils import CFGConfig\n\nconfig = CFGConfig(\n    tool_name=\"magda_dsl\",\n    description=\"Generates MAGDA DSL code for REAPER automation\",\n    grammar=grammar_string,\n    syntax=\"lark\",\n)\n</code></pre>"},{"location":"python/api-reference/#build_openai_cfg_tool","title":"build_openai_cfg_tool","text":"<pre><code>def build_openai_cfg_tool(config: CFGConfig) -&gt; dict[str, Any]\n</code></pre> <p>Builds an OpenAI CFG tool payload from a CFGConfig. This function: - Cleans the grammar using <code>LarkBackend.clean_grammar_for_cfg()</code> to remove unsupported Lark directives - Returns the properly formatted OpenAI tool structure - Ensures the syntax defaults to \"lark\" if not specified</p> <p>Example:</p> <pre><code>from grammar_school.openai_utils import CFGConfig, build_openai_cfg_tool\n\ntool = build_openai_cfg_tool(CFGConfig(\n    tool_name=\"magda_dsl\",\n    description=\"Generates MAGDA DSL code for REAPER automation\",\n    grammar=grammar_string,\n    syntax=\"lark\",\n))\n# Add tool to OpenAI request: tools = [tool]\n</code></pre>"},{"location":"python/api-reference/#get_openai_text_format_for_cfg","title":"get_openai_text_format_for_cfg","text":"<pre><code>def get_openai_text_format_for_cfg() -&gt; dict[str, Any]\n</code></pre> <p>Returns the text format configuration that should be used when making OpenAI requests with CFG tools. When using CFG, the text format must be set to \"text\" (not JSON schema) because the output is DSL code, not JSON.</p> <p>Example:</p> <pre><code>from grammar_school.openai_utils import get_openai_text_format_for_cfg\n\nparams[\"text\"] = get_openai_text_format_for_cfg()\n</code></pre>"},{"location":"python/api-reference/#clean_grammar_for_cfg","title":"clean_grammar_for_cfg","text":"<pre><code>@staticmethod\ndef LarkBackend.clean_grammar_for_cfg(grammar: str) -&gt; str\n</code></pre> <p>Cleans a Lark grammar for use with CFG systems (e.g., GPT-5). Removes Lark-specific directives that aren't supported in standard CFG: - <code>%import</code> directives - <code>%ignore</code> directives - Other <code>%</code>-prefixed directives</p>"},{"location":"python/api-reference/#cfgprovider-interface","title":"CFGProvider Interface","text":"<p>Grammar School provides a <code>CFGProvider</code> interface for integrating with different LLM providers that support CFG. This allows you to use the same API with different LLM providers.</p> <pre><code>from abc import ABC, abstractmethod\n\nclass CFGProvider(ABC):\n    @abstractmethod\n    def build_tool(self, tool_name: str, description: str, grammar: str, syntax: str) -&gt; dict[str, Any]:\n        \"\"\"Builds the vendor-specific CFG tool payload.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_text_format(self) -&gt; dict[str, Any]:\n        \"\"\"Returns the text format configuration for the vendor's API.\"\"\"\n        pass\n\n    @abstractmethod\n    def generate(self, prompt: str, model: str, tools: list[dict], text_format: dict, client=None, **kwargs) -&gt; Any:\n        \"\"\"Generates DSL code using the vendor's LLM.\"\"\"\n        pass\n\n    @abstractmethod\n    def extract_dsl_code(self, response: Any) -&gt; str:\n        \"\"\"Extracts DSL code from the vendor's response.\"\"\"\n        pass\n</code></pre>"},{"location":"python/api-reference/#openaicfgprovider","title":"OpenAICFGProvider","text":"<pre><code>from grammar_school.cfg_vendor import OpenAICFGProvider\n\nprovider = OpenAICFGProvider()\ncfg_tool = provider.build_tool(\n    tool_name=\"task_dsl\",\n    description=\"Task management DSL\",\n    grammar=grammar_string,\n    syntax=\"lark\",\n)\ntext_format = provider.get_text_format()\n</code></pre> <p>The <code>OpenAICFGProvider</code> class implements the <code>CFGProvider</code> interface for OpenAI's API. It handles: - Building OpenAI-specific CFG tool payloads - Configuring text format for CFG requests - Generating DSL code using OpenAI's API - Extracting DSL code from OpenAI responses</p> <p>Example:</p> <pre><code>from grammar_school.cfg_vendor import OpenAICFGProvider\nfrom openai import OpenAI\n\nprovider = OpenAICFGProvider()\ncfg_tool = provider.build_tool(\n    tool_name=\"task_dsl\",\n    description=\"Task management DSL\",\n    grammar=grammar.backend.grammar,\n    syntax=\"lark\",\n)\ntext_format = provider.get_text_format()\n\nclient = OpenAI()\nresponse = client.chat.completions.create(\n    model=\"gpt-5\",\n    messages=[{\"role\": \"user\", \"content\": \"Create a task\"}],\n    tools=[cfg_tool],\n    tool_choice={\"type\": \"required\", \"tool\": {\"name\": \"task_dsl\"}},\n    **text_format,\n)\n\ndsl_code = provider.extract_dsl_code(response)\ngrammar.execute(dsl_code)\n</code></pre>"},{"location":"python/core-types/","title":"Python Core Types","text":"<p>Detailed documentation of core types in the Grammar School Python implementation.</p>"},{"location":"python/core-types/#ast-types","title":"AST Types","text":""},{"location":"python/core-types/#value","title":"Value","text":"<p>Represents a value in the AST (number, string, identifier, bool).</p> <pre><code>@dataclass\nclass Value:\n    kind: str  # \"number\" | \"string\" | \"identifier\" | \"bool\"\n    value: Any\n</code></pre> <p>Example: <pre><code>value = Value(kind=\"string\", value=\"hello\")\n</code></pre></p>"},{"location":"python/core-types/#arg","title":"Arg","text":"<p>Represents a named argument to a call.</p> <pre><code>@dataclass\nclass Arg:\n    name: str\n    value: Value\n</code></pre> <p>Example: <pre><code>arg = Arg(name=\"name\", value=Value(kind=\"string\", value=\"Alice\"))\n</code></pre></p>"},{"location":"python/core-types/#call","title":"Call","text":"<p>Represents a single function call with named arguments.</p> <pre><code>@dataclass\nclass Call:\n    name: str\n    args: dict[str, Value]\n</code></pre> <p>Example: <pre><code>call = Call(\n    name=\"greet\",\n    args={\"name\": Value(kind=\"string\", value=\"Alice\")}\n)\n</code></pre></p>"},{"location":"python/core-types/#callchain","title":"CallChain","text":"<p>Represents a chain of calls connected by dots (method chaining).</p> <pre><code>@dataclass\nclass CallChain:\n    calls: list[Call]\n</code></pre> <p>Example: <pre><code>chain = CallChain(calls=[\n    Call(name=\"track\", args={}),\n    Call(name=\"add_clip\", args={})\n])\n</code></pre></p>"},{"location":"python/core-types/#method-decorators","title":"Method Decorators","text":""},{"location":"python/core-types/#method","title":"@method","text":"<p>Decorator to mark a method as a DSL handler. Methods contain their implementation directly.</p> <pre><code>@method\ndef greet(self, name):\n    print(f\"Hello, {name}!\")\n</code></pre> <p>Note: The <code>Action</code> and <code>Runtime</code> types still exist internally for the two-layer architecture, but users don't need to interact with them directly when using <code>@method</code>.</p>"},{"location":"python/grammar/","title":"Grammar Definition","text":"<p>Guide to defining grammars in Grammar School Python.</p>"},{"location":"python/grammar/#default-grammar","title":"Default Grammar","text":"<p>Grammar School provides a default grammar that supports:</p> <ul> <li>Function calls: <code>greet(name=\"Alice\")</code></li> <li>Method chaining: <code>track().add_clip()</code></li> <li>Named arguments: <code>func(name=\"value\", count=2)</code></li> <li>Positional arguments: <code>func(\"value\", 2)</code></li> <li>Various value types: numbers, strings, identifiers, booleans</li> </ul>"},{"location":"python/grammar/#using-the-default-grammar","title":"Using the Default Grammar","text":"<pre><code>from grammar_school import Grammar, method\n\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL()  # Uses default grammar\n</code></pre>"},{"location":"python/grammar/#custom-grammar","title":"Custom Grammar","text":"<p>You can provide a custom grammar string:</p> <pre><code>custom_grammar = \"\"\"\nstart: call_chain\n\ncall_chain: call ('.' call)*\ncall: IDENTIFIER \"(\" args? \")\"\nargs: arg (',' arg)*\narg: IDENTIFIER \"=\" value | value\nvalue: NUMBER | STRING | IDENTIFIER | BOOL\n\nIDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/\nNUMBER: /-?\\\\d+(\\\\.\\\\d+)?/\nSTRING: /\"([^\"\\\\\\\\]|\\\\\\\\.)*\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/\nBOOL: \"true\" | \"false\"\n\"\"\"\n\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL(grammar=custom_grammar)\n</code></pre>"},{"location":"python/grammar/#grammar-rules-with-rule-decorator","title":"Grammar Rules with @rule Decorator","text":"<p>For advanced use cases, you can use the <code>@rule</code> decorator:</p> <pre><code>from grammar_school import rule\n\n@rule(\"call_chain: call ('.' call)*\")\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n</code></pre>"},{"location":"python/grammar/#grammar-syntax","title":"Grammar Syntax","text":"<p>Grammar School uses Lark for parsing, which supports:</p> <ul> <li>EBNF-style rules</li> <li>Regular expressions for terminals</li> <li>Operator precedence</li> <li>Ambiguity resolution</li> </ul> <p>See the Lark documentation for complete grammar syntax.</p>"},{"location":"python/interpreter/","title":"Interpreter","text":"<p>The interpreter executes methods directly from the AST.</p>"},{"location":"python/interpreter/#overview","title":"Overview","text":"<p>The <code>Interpreter</code> class walks the <code>CallChain</code> AST, coerces <code>Value</code> objects to native Python types, and calls <code>@method</code> handlers directly. Methods execute immediately when called.</p>"},{"location":"python/interpreter/#basic-usage","title":"Basic Usage","text":"<pre><code>from grammar_school import Grammar, method\n\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL()\n\n# The interpreter is created automatically by Grammar\n# Methods execute directly when called\ndsl.execute('greet(name=\"Alice\")')  # Prints: Hello, Alice!\n</code></pre>"},{"location":"python/interpreter/#how-it-works","title":"How It Works","text":"<ol> <li>Walk the CallChain - Iterates through each <code>Call</code> in the chain</li> <li>Coerce Values - Converts <code>Value</code> objects to native Python types (str, int, float, bool)</li> <li>Dispatch to Methods - Calls the appropriate <code>@method</code> handler</li> <li>Execute Directly - Methods run immediately with their implementation</li> </ol>"},{"location":"python/interpreter/#value-coercion","title":"Value Coercion","text":"<p>The interpreter automatically coerces <code>Value</code> objects:</p> <ul> <li><code>Value(kind=\"string\", value=\"hello\")</code> \u2192 <code>\"hello\"</code></li> <li><code>Value(kind=\"number\", value=42)</code> \u2192 <code>42</code></li> <li><code>Value(kind=\"bool\", value=True)</code> \u2192 <code>True</code></li> <li><code>Value(kind=\"identifier\", value=\"myVar\")</code> \u2192 <code>\"myVar\"</code></li> </ul>"},{"location":"python/interpreter/#method-execution","title":"Method Execution","text":"<p>Methods execute directly - they can do anything:</p> <pre><code>class MusicDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.tracks = []\n        self.current_track = None\n\n    @method\n    def track(self, name):\n        # Implementation runs directly\n        self.current_track = {\"name\": name, \"clips\": []}\n        self.tracks.append(self.current_track)\n\n    @method\n    def add_clip(self, start, length):\n        # Access state via self\n        if self.current_track:\n            self.current_track[\"clips\"].append({\n                \"start\": start,\n                \"length\": length\n            })\n</code></pre> <p>Methods can: - Perform side effects (print, file I/O, API calls) - Maintain state via <code>self</code> attributes - Return values (if needed) - Access previous state from <code>self</code></p>"},{"location":"python/overview/","title":"Python API Overview","text":"<p>The Python implementation of Grammar School provides a clean, decorator-based API for building DSLs.</p>"},{"location":"python/overview/#quick-example","title":"Quick Example","text":"<pre><code>from grammar_school import Grammar, method\n\nclass MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL()\ndsl.execute('greet(name=\"World\")')\n</code></pre>"},{"location":"python/overview/#key-components","title":"Key Components","text":""},{"location":"python/overview/#grammar","title":"Grammar","text":"<p>The <code>Grammar</code> class orchestrates parsing and interpretation:</p> <pre><code>class MyDSL(Grammar):\n    @method\n    def greet(self, name):\n        print(f\"Hello, {name}!\")\n\ndsl = MyDSL()\ndsl.execute('greet(name=\"World\")')\n</code></pre>"},{"location":"python/overview/#decorators","title":"Decorators","text":"<ul> <li><code>@method</code> - Marks a method as a DSL handler (contains implementation)</li> <li><code>@rule</code> - Defines custom grammar rules (advanced)</li> </ul>"},{"location":"python/overview/#core-types","title":"Core Types","text":"<ul> <li><code>Value</code> - AST value node</li> <li><code>Arg</code> - Named argument</li> <li><code>Call</code> - Function call</li> <li><code>CallChain</code> - Chain of calls</li> </ul>"},{"location":"python/overview/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Core Types - Detailed type information</li> <li>Grammar - Grammar definition guide</li> </ul>"},{"location":"python/runtime/","title":"Runtime (Internal Architecture)","text":"<p>Note: With the unified <code>@method</code> interface, you don't need to implement Runtime. Methods execute directly. This page documents the internal architecture for advanced users.</p>"},{"location":"python/runtime/#overview","title":"Overview","text":"<p>Internally, Grammar School maintains a two-layer architecture: 1. Grammar layer: Parses DSL and calls methods 2. Runtime layer: Executes methods (handled automatically)</p> <p>When using <code>@method</code>, the Runtime layer is handled automatically - you just write methods with their implementation.</p>"},{"location":"python/runtime/#using-method-recommended","title":"Using @method (Recommended)","text":"<p>With <code>@method</code>, you don't need Runtime:</p> <pre><code>from grammar_school import Grammar, method\n\nclass MyDSL(Grammar):\n    def __init__(self):\n        super().__init__()\n        self.tracks = []\n\n    @method\n    def track(self, name):\n        # Implementation runs directly\n        self.tracks.append({\"name\": name})\n        print(f\"Created track: {name}\")\n\ndsl = MyDSL()\ndsl.execute('track(name=\"Drums\")')  # No runtime needed!\n</code></pre>"},{"location":"python/runtime/#internal-architecture","title":"Internal Architecture","text":"<p>The <code>Runtime</code> protocol still exists internally, but is handled automatically when using <code>@method</code>. The framework: 1. Parses DSL code 2. Calls your <code>@method</code> handlers directly 3. Methods execute immediately</p> <p>You can manage state using <code>self</code> attributes in your Grammar class.</p>"}]}