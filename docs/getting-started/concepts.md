# Core Concepts

Grammar School follows a consistent conceptual model across all language implementations.

## The Pipeline

Every DSL program flows through this pipeline:

```
DSL Code (string)
   ↓
Parse → CallChain (AST)
   ↓
Interpret → []Action (plan)
   ↓
Execute (runtime)
```

## DSL Program

A DSL program is a plain string, typically generated by an LLM:

```text
track(name="Drums").add_clip(start=0, length=8)
Cmaj7(1,1), Fmaj7(2,1)
tracks().filter(name~="FX").mute()
```

## Abstract Syntax Tree (AST)

Grammar School uses a simple AST structure:

- **Value**: Represents a value (number, string, identifier, bool)
- **Arg**: A named argument with a value
- **Call**: A function call with named arguments
- **CallChain**: A chain of calls connected by dots (method chaining)

### Example AST

For the code `greet(name="Alice", count=2)`:

```
CallChain
  └─ Call(name="greet")
      ├─ Arg(name="name", value=Value(kind="string", value="Alice"))
      └─ Arg(name="count", value=Value(kind="number", value=2))
```

## Actions

Semantic evaluation produces `Action` objects:

```python
Action(
    kind="create_track",
    payload={"name": "Drums", "color": "blue"}
)
```

Actions are runtime instructions that your `Runtime` implementation executes.

## Verbs

Verbs are semantic handlers that map DSL function calls to Actions:

=== "Python"

    ```python
    @verb
    def track(self, name, color=None, _context=None):
        return Action(kind="create_track", payload={"name": name, "color": color})
    ```

=== "Go"

    ```go
    func (d *MyDSL) Track(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {
        name := args["name"].Str
        color := ""
        if c, ok := args["color"]; ok {
            color = c.Str
        }
        action := gs.Action{
            Kind: "create_track",
            Payload: map[string]interface{}{
                "name":  name,
                "color": color,
            },
        }
        return []gs.Action{action}, ctx, nil
    }
    ```

## Runtime

The Runtime executes Actions produced by the interpreter:

=== "Python"

    ```python
    class MyRuntime(Runtime):
        def execute(self, action: Action) -> None:
            if action.kind == "create_track":
                # Create a track...
                pass
    ```

=== "Go"

    ```go
    type MyRuntime struct{}

    func (r *MyRuntime) ExecuteAction(ctx context.Context, a gs.Action) error {
        switch a.Kind {
        case "create_track":
            // Create a track...
        }
        return nil
    }
    ```

## Context

Context can be passed between verb handlers to maintain state:

=== "Python"

    ```python
    @verb
    def track(self, name, _context=None):
        # _context contains previous action or None
        return Action(...), new_context  # Return new context
    ```

=== "Go"

    ```go
    func (d *MyDSL) Track(args gs.Args, ctx *gs.Context) ([]gs.Action, *gs.Context, error) {
        // ctx contains previous context
        newCtx := gs.NewContext()
        newCtx.Set("last_track", name)
        return []gs.Action{action}, newCtx, nil
    }
    ```

## Grammar

Grammars define the syntax of your DSL. Grammar School provides a default grammar, but you can customize it:

=== "Python"

    ```python
    custom_grammar = """
    start: call_chain
    call_chain: call ('.' call)*
    # ... more rules
    """
    grammar = Grammar(dsl, grammar=custom_grammar)
    ```

=== "Go"

    ```go
    customGrammar := `
    start: call_chain
    call_chain: call ('.' call)*
    // ... more rules
    `
    engine, _ := gs.NewEngine(customGrammar, dsl, parser)
    ```

